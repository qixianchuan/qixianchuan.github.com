<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Node服务器端开发第三天]]></title>
      <url>%2Fblog%2F2016%2F12%2F08%2Fnode-third%2F</url>
      <content type="text"><![CDATA[核心模块和NPM、文件操作、文件流、网络操作 核心模块核心模块的意义 如果只是在服务器运行JavaScript代码，意义并不大，因为无法实现任何功能（读写文件，访问网络）。 Node 的用处在于它本身还提供的一系列功能模块，用于与操作系统互动。 这些核心的功能模块在 Node 中内置。 内置如下模块： path：处理文件路径。 fs：操作文件系统。 child_process：新建子进程。 util：提供一系列实用小工具。 http：提供HTTP服务器功能。 url：用于解析URL。 querystring：解析URL中的查询字符串。 crypto：提供加密和解密功能。 其他 Node Package 由于Node是一套轻内核的平台，虽然提供了一系列的内置模块，但是不足以满足开发者的需求，于是乎出现了包（Package）的概念。与核心模块类似，就是将一些预先设计好的功能或者说API封装到一个文件夹，提供给开发者使用； 包的加载机制 与内置模块相同，包的加载同样使用require方法 1const express = require('express'); 加载机制也和内置模块加载机制相同 加载注意事项： 先在系统核心（优先级最高）的模块中找； 12const fs = require('fs');// 永远加载内部核心模块fs 然后再到当前项目中 node_modules 目录中找； 如何管理好自己的包包 由于Node本身并没有太多的功能性API，所以市面上涌现出大量的第三方人员开发出来的Package 包的生态圈一旦繁荣起来，就必须有工具去代替人脑或者文档的方式管理 这时候NPM诞生了 NPM 随着时间的发展，NPM 出现了两层概念： 一层含义是 Node 的开放式模块登记和管理系统，亦可以说是一个生态圈，一个社区 另一层含义是 Node 默认的模块管理器，是一个命令行下的软件，用来安装和管理 Node 模块。 官方链接： https://www.npmjs.com/ 国内加速镜像： https://npm.taobao.org/ 安装NPM NPM 不需要单独安装。默认在安装 Node 的时候，会连带一起安装 NPM。 但是，Node 附带的 NPM 可能不是最新版本，最好用下面的命令，更新到最新版本。 1$ npm install npm -g 默认安装到当前系统 Node 所在目录下。 由于之前使用 NVM 的方式安装的 Node 所以需要重新配置 NPM 的全局目录 配置NPM的全局目录1$ npm config set prefix [pathtonpm] 将NPM目录配置到其他目录时，必须将该目录放到环境变量中，否则无法再全局使用 常用NPM命令 https://docs.npmjs.com/ 1234567891011npm config [ls|list|set|get] [name] [value]npm init [--yes|-y]npm search [name]npm info [name]npm install [--global|-g] [name]npm uninstall [--global|-g] [name]npm list [--global|-g]npm outdated [--global|-g]npm update [--global|-g] [name]npm run [task]npm cache [clean] 文件操作相关模块Node内核提供了很多与文件操作相关的模块，每个模块都提供了一些最基本的操作API，在NPM中也有社区提供的功能包 fs：基础的文件操作 API path：提供和路径相关的操作 API readline：用于读取大文本文件，一行一行读 fs-extra（第三方）：https://www.npmjs.com/package/fs-extra 同步或异步调用 fs模块对文件的几乎所有操作都有同步和异步两种形式 例如：readFile() 和 readFileSync() 区别： 同步调用会阻塞代码的执行，异步则不会 异步调用会将读取任务下达到任务队列，直到任务执行完成才会回调 异常处理方面，同步必须使用 try catch 方式，异步可以通过回调函数的第一个参数 123456789101112131415console.time('sync');try &#123; var data = fs.readFileSync(path.join('C:\\Users\\iceStone\\Downloads', 'H.mp4')); // console.log(data);&#125; catch (error) &#123; throw error;&#125;console.timeEnd('sync');console.time('async');fs.readFile(path.join('C:\\Users\\iceStone\\Downloads', 'H.mp4'), (error, data) =&gt; &#123; if (error) throw error; // console.log(data);&#125;);console.timeEnd('async'); 路径模块在文件操作的过程中，都必须使用物理路径（绝对路径），path模块提供了一系列与路径相关的 API 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879console.log('join用于拼接多个路径部分，并转化为正常格式');const temp = path.join(__dirname, '..', 'lyrics', './友谊之光.lrc');console.log(temp);console.log('获取路径中的文件名');console.log(path.basename(temp));console.log('获取路径中的文件名并排除扩展名');console.log(path.basename(temp, '.lrc'));console.log('====================================');console.log('获取不同操作系统的路径分隔符');console.log(process.platform + '的分隔符为 ' + path.delimiter);console.log('一般用于分割环境变量');console.log(process.env.PATH.split(path.delimiter));console.log('====================================');console.log('获取一个路径中的目录部分');console.log(path.dirname(temp));console.log('====================================');console.log('获取一个路径中最后的扩展名');console.log(path.extname(temp));console.log('====================================');console.log('将一个路径解析成一个对象的形式');const pathObject = path.parse(temp);console.log(pathObject);console.log('====================================');console.log('将一个路径对象再转换为一个字符串的形式');// pathObject.name = '我终于失去了你';pathObject.base = '我终于失去了你.lrc';console.log(pathObject);console.log(path.format(pathObject));console.log('====================================');console.log('获取一个路径是不是绝对路径');console.log(path.isAbsolute(temp));console.log(path.isAbsolute('../lyrics/爱的代价.lrc'));console.log('====================================');console.log('将一个路径转换为当前系统默认的标准格式，并解析其中的./和../');console.log(path.normalize('c:/develop/demo\\hello/../world/./a.txt'));console.log('====================================');console.log('获取第二个路径相对第一个路径的相对路径');console.log(path.relative(__dirname, temp));console.log('====================================');console.log('以类似命令行cd命令的方式拼接路径');console.log(path.resolve(temp, 'c:/', './develop', '../application'));console.log('====================================');console.log('获取不同平台中路径的分隔符（默认）');console.log(path.sep);console.log('====================================');console.log('允许在任意平台下以WIN32的方法调用PATH对象');// console.log(path.win32);console.log(path === path.win32);console.log('====================================');console.log('允许在任意平台下以POSIX的方法调用PATH对象');console.log(path === path.posix); 源码地址：https://github.com/nodejs/node/blob/master/lib/path.js 文件读取Node中文件读取的方式主要有： fs.readFile(file[, options], callback(error, data))1234fs.readFile('c:\\demo\1.txt', 'utf8', (err, data) =&gt; &#123; if (err) throw err; console.log(data);&#125;); fs.readFileSync(file[, options])1234567try &#123; const data = fs.readFileSync('c:\\demo\1.txt', 'utf8'); console.log(data);&#125; catch(e) &#123; // 文件不存在，或者权限错误 throw e;&#125; fs.createReadStream(path[, options])12345678const stream = fs.createReadStream('c:\\demo\1.txt');let data = ''stream.on('data', (trunk) =&gt; &#123; data += trunk;&#125;);stream.on('end', () =&gt; &#123; console.log(data);&#125;); 由于Windows平台下默认文件编码是GBK，在Node中不支持，可以通过iconv-lite解决 Readline模块逐行读取文本内容12345678910const readline = require('readline');const fs = require('fs');const rl = readline.createInterface(&#123; input: fs.createReadStream('sample.txt')&#125;);rl.on('line', (line) =&gt; &#123; console.log('Line from file:', line);&#125;); 文件写入Node中文件写入的方式主要有： fs.writeFile(file, data[, options], callback(error))123fs.writeFile('c:\\demo\a.txt', new Date(), (error) =&gt; &#123; console.log(error);&#125;); fs.writeFileSync(file, data[, options])123456try &#123; fs.writeFileSync('c:\\demo\a.txt', new Date());&#125; catch (error) &#123; // 文件夹不存在，或者权限错误 console.log(error);&#125; fs.createWriteStream(path[,option])123456var streamWriter = fs.createWriteStream('c:\\demo\a.txt');setInterval(() =&gt; &#123; streamWriter.write(`$&#123;new Date&#125;\n`, (error) =&gt; &#123; console.log(error); &#125;);&#125;, 1000); 文件写入fs.appendFile(file,data[,options],callback(err))123456// 相比较之前文件流的方式，这种方式不会占用文件资源，append完成就会释放setInterval(() =&gt; &#123; fs.appendFile('c:\\demo\a.txt',`$&#123;new Date&#125;\n`, (error) =&gt; &#123; console.log(error); &#125;);&#125;, 1000); fs.appendFileSync(file,data[,options])123setInterval(() =&gt; &#123; fs.appendFileSync('c:\\demo\a.txt',`$&#123;new Date&#125;\n`);&#125;, 1000); 其他常见文件操作验证路径是否存在（过时的API） fs.exists(path,callback(exists)) fs.existsSync(path) // =&gt; 返回布尔类型 exists 获取文件信息 fs.stat(path,callback(err,stats)) fs.statSync(path) // =&gt; 返回一个fs.Stats实例 移动文件或重命名文件或目录 与命令行相同，重命名操作也可以实现文件移动 fs.rename(oldPath,newPath,callback) fs.renameSync(oldPath,newPath) 删除文件 fs.unlink(path,callback(err)) fs.unlinkSync(path) 其他常见文件夹操作创建一个目录 fs.mkdir(path[,model],callback) fs.mkdirSync(path[,model]) 删除一个空目录 fs.rmdir(path,callback) fs.rmdirSync(path) 读取一个目录 fs.readdir(path,callback(err,files)) fs.readdirSync(path) // =&gt; 返回files 文件监视利用文件监视实现自动 markdown 文件转换 相关链接： https://github.com/chjj/marked https://github.com/Browsersync/browser-sync 实现思路： 利用fs模块的文件监视功能监视指定MD文件 当文件发生变化后，借助marked包提供的markdown to html功能将改变后的MD文件转换为HTML 再将得到的HTML替换到模版中 最后利用BrowserSync模块实现浏览器自动刷新 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const fs = require('fs');const path = require('path');var marked = require('marked');var bs = require('browser-sync').create();var target = path.join(__dirname, process.argv[2] || './README.md');var filename = path.basename(target, path.extname(target)) + '.html';var targetHtml = path.join(path.dirname(target), filename);bs.init(&#123; server: path.dirname(target), index: filename, notify: false&#125;);bs.reload(filename);var template = `&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt;&#123;&#123;&#123;styles&#125;&#125;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;article class="markdown"&gt; &#123;&#123;&#123;body&#125;&#125;&#125; &lt;/article&gt;&lt;/body&gt;&lt;/html&gt;`;fs.readFile(path.join(__dirname, './markdown.css'), 'utf8', (error, css) =&gt; &#123; if (error) throw error; template = template.replace('&#123;&#123;&#123;styles&#125;&#125;&#125;', css); var handler = (current, previous) =&gt; &#123; fs.readFile(target, 'utf8', (error, content) =&gt; &#123; var html = template.replace('&#123;&#123;&#123;body&#125;&#125;&#125;', marked(content)); fs.writeFile(targetHtml, html, (error) =&gt; &#123; if (!error) &#123; console.log(`updated@$&#123;new Date()&#125;`); bs.reload(filename); &#125; &#125;); &#125;); &#125;; handler(); fs.watchFile(target, &#123; interval: 100 &#125;, handler);&#125;); 缓冲区处理什么是缓冲区 缓冲区就是内存中操作数据的容器 只是数据容器而已 通过缓冲区可以很方便的操作二进制数据 而且在大文件操作时必须有缓冲区 为什么要有缓冲区 JavaScript是比较擅长处理字符串，但是早期的应用场景主要用于处理HTML文档，不会有太大篇幅的数据处理，也不会接触到二进制的数据。 而在Node中操作数据、网络通信是没办法完全以字符串的方式操作的，简单来说 所以在Node中引入了一个二进制的缓冲区的实现：Buffer 文件流 网络操作]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5 基础]]></title>
      <url>%2Fblog%2F2016%2F11%2F29%2Fhtml5-note%2F</url>
      <content type="text"><![CDATA[HTML5 肯定不是多了一些标签就完事了 HTML5 根酷炫没什么关系，更多的职责是功能，而不是外观 1. 概要1.1. WEB技术阶段 Web 1.0 内容为主，主要流行HTML和CSS Web 2.0 动态网页，流行AJAX/JavaScript/DOM HTML5 时代，WEB开发回归富客户端 1.2. 什么是HTML5 是HTML的超集，不仅仅是HTML，更多的是JavaScript API和CSS的提升， 构建 Web 应用程序整体解决方案 API的概念就是我们编程时所依赖的东西的总称 1.3. 什么是Web Application HTML5 前身，由WHATWG组织提出 推出的目的主要是提高Web应用程序的功能 2007年提交到W3C组织，成了现在我们看到的HTML5 1.4. HTML5应用场景 极具表现力的网页 案例非常多 网页应用程序 PC端：iCloud、百度脑图、Office 365··· APP端：淘宝、京东、美团··· WeChat端：淘宝、京东、美团··· 混合式本地应用 PC端：网易云音乐、有道词典··· APP端：淘宝、京东、美团··· 简单的游戏 1.5. H5新特性概要 我们这里只是列出了H5中所有的新特性，大部分内容会在以后的课程中专门学习 1.5.1. HTML 标签 更语义化标签 智能表单 新的表单类型，如：email,url,number 新增表单功能属性，如：autocomplete，autofocus 虚拟键盘适配，通过表单的类型决定移动端弹出的键盘类型 网页多媒体，我们可以在网页中直接通过原生方式播放视频音频 音频 视频 字幕 属性，语义化属性，在移动Web bootstrap的课程中用到 链接关系描述 结构数据标记 ARIA 自定义属性 Canvas，提供网页绘图的可能，后面在Canvas课程会专门去学习 2D 绘图 3D (WebGL) SVG，仅仅了解即可 1.5.2. JavaScript API 核心平台提升，JS在DOM和BOM两个方向上都新增了很多api，便于开发应用程序 新的选择器 Element.classList 访问历史API 全屏API 网页存储，提供网页中操作客户端本地存储的API Application Cache localStorage sessionStorage WebSQL IndexedDB 设备信息访问，JS可以访问硬件的一些信息，我们在移动手机APP的课程中再看 网络状态 硬件访问 设备方向 地理围栏 拖放操作 网页内拖放 桌面拖入 文件 文件系统API FileReader 网络访问，后面AJAX和服务端编程的课程再去看 XMLHttpRequest fetch WebSocket 多线程 桌面通知 1.5.3. CSS 后面详细讨论 1.6. HTML5 骨架1234567891011121314&lt;!-- HTML5的DOCTYPE声明做了最大简化 --&gt;&lt;!DOCTYPE html&gt;&lt;!-- lang属性根据当前网页大量使用的语言种类决定，大量使用中文则使用zh-CN，英文则使用en --&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;!-- 在标准的HTML5骨架中charset是直接在meta中设置charset --&gt; &lt;!-- 字符编码的设置一定是在head中的第一行 --&gt; &lt;title&gt;页面标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; HTML5的DOCTYPE声明做了最大简化 在标准的HTML5骨架中charset是直接在meta中设置charset 字符编码的设置一定是在head中的第一行，再晚就来不及了 lang属性根据当前网页大量使用的语言种类决定，大量使用中文则使用zh-CN，英文则使用en 2. 语义化标签2.1. 什么是语义化标签 HTML5中制定了一系列语义化标签： section：独立的内容节块，一般包含标题和内容 article：一种特殊的section，定义文档中的具体的文章内容 nav：页面导航的链接组 aside：标签用来装载非正文的内容，此标签中的文字权重低 header：定义文档的页眉，不仅仅是文档的页头可以使用header，一个独立块的头部也应该使用header footer：定义section或document的页脚 我们应该根据内容的性质决定使用特定的标签 h1一定只能出现一个，不是HTML的约定，页面中最重要的内容 time标签专门用于时间， datetime应该是一个标准时间格式， pubdate指的是当前时间为article的发布时间 在H5中，主体结构标签默认和DIV都是相同的块级效果， 但是DIV没有语义，而以上标签有特定语义 2.2. 为什么要有语义化标签 能够便于开发者阅读和写出更优雅的代码，代码如诗 同时让浏览器或是网络爬虫可以很好地解析，从而更好分析其中的内容 使用语义化标签会具有更好地搜索引擎优化 切记 HTML的职责是描述一块内容是什么（或其意义） 而不是它长的什么样子，它的外观应该由CSS来决定。 3. 智能表单3.1. 新的表单类型 email - 限定输入内容为邮箱地址，表单提交时会校验格式 url - 限定输入内容为URL，表单提交时会校验格式 number - 限定输入内容为数字，表单提交时会校验格式 range - 数值范围选择器 Date Pickers - 日期时间选择器 样式不能修改，移动端用的比较多，因为移动端显示的是系统的时间或日期选择器 date - 选取日、月、年 month - 选取月、年 week - 选取周和年 time - 选取时间（小时和分钟） datetime - 选取时间、日、月、年，浏览器兼容性不好，效果等同于datetime-local datetime-local - 选取本地时间、日、月、年 search - 搜索域，语义化，表示定义搜索框 3.2. 新的表单属性 form 上使用的新属性 autocomplete 设置整个表单是否开启自动完成 on|off novalidate 设置H5的表单校验是否工作 true 不工作 不加该属性代表校验 input 上使用的新属性 autocomplete 单独设置每个文本框的自动完成 autofocus 设置当前文本域页面加载完了过后自动得到焦点 form 属性是让表单外的表单元素也可以跟随表单一起提交 form overrides formaction 在submit上重写表单的特定属性，当点击当前submit时会以当前值使用 formenctype, formmethod, formnovalidate, formtarget list 作用就是指定当前文本框的自动完成列表的数据 datalist 在界面上是看不见的，只是用于定义数据列表的 min / max / step min max 限制值的范围，但是不会再输入时限制，提交时校验， step设置的是每次加减的增量 主要使用在number range datepicker上 multiple 文本域的多选 pattern 设置文本框的匹配格式（正则） placeholder 文本框占位符 required 限制当前input为必须的 3.3. 虚拟键盘适配 在移动端中，我们可以通过不同的表单类型控制弹出的键盘类型 3.4. 关于什么时候使用H5的新特性，能不能使用新特性的问题 无伤大雅的地方直接用 比如一个文本框，加上placeholder就具备占位文本提示功能，浏览器不支持也不会报错，那就可以直接使用 再比如&lt;input type=&quot;email&quot;&gt;，如果浏览器不支持，默认会显示文本框，那也可以直接用。 4. 网页多媒体4.1. 音频 定义音频播放组件 1&lt;audio src="要播放的音频文件"&gt;&lt;/audio&gt; 4.2. 视频 定义播放视频组件 1&lt;video src="要播放的视频文件"&gt;&lt;/video&gt; 4.3. 旧版本浏览器提示 如果HTML中遇到不能识别的标签，就会将该标签当做DIV(块级元素) 那么video中的innerHTML也就会直接显示在界面上 利用这个特点我们可以实现不支持video标签的浏览器提示 1234&lt;video src="demo.mp4"&gt; &lt;!-- 如果浏览器不识别video标签，以下内容可以直接显示在浏览器上 --&gt; &lt;p&gt;抱歉，您的浏览器不支持视频播放！&lt;/p&gt;&lt;/video&gt; 4.4. 格式兼容 每个浏览器的音视频格式支持不同（版权问题） 需要兼容更多的浏览器，可以通过定义多个&lt;source&gt;的方式实现 html解析过程中会找其中第一个能认识的格式播放，一旦找到认识的视频格式，就不会再往后找了 1234567&lt;video controls width="500"&gt; &lt;!-- 分析第一个source格式是否支持，如果支持则加载该文件，不支持继续往下解析 --&gt; &lt;source src="chrome.mp4"&gt; &lt;source src="chrome.ogv"&gt; &lt;source src="chrome.webm"&gt; &lt;p&gt;抱歉，您的浏览器不支持视频播放！&lt;/p&gt;&lt;/video&gt; 因此不管是audio还是video都不要直接设置标签的src 4.5. 多媒体标签属性 属性 含义 controls 决定是否显示控制菜单 autoplay 自动播放 loop 循环播放 height/width 定义播放器的宽高，只会在视频标签中生效 preload 预加载 是否在页面加载完成并且没有开始播放时就开始加载文件，如果有自动播放属性则该属性无意义 4.6. 自定义播放器外观 隐藏原生的控制菜单，也就是删除标签中的controls属性 自己设计一套界面控制元素，比如播放按钮，音量控制开关之类 为每个不同的控制元素注册对应的事件 在事件中通过视频元素的API实现自定义播放器的效果 具体的多媒体元素API表： 4.6.1. 方法 方法 描述 addTextTrack() 向音频/视频添加新的文本轨道 canPlayType() 检测浏览器是否能播放指定的音频/视频类型 load() 重新加载音频/视频元素 play() 开始播放音频/视频 pause() 暂停当前播放的音频/视频 4.6.2. 属性 属性 描述 audioTracks 返回表示可用音轨的 AudioTrackList 对象 autoplay 设置或返回是否在加载完成后随即播放音频/视频 buffered 返回表示音频/视频已缓冲部分的 TimeRanges 对象 controller 返回表示音频/视频当前媒体控制器的 MediaController 对象 controls 设置或返回音频/视频是否显示控件（比如播放/暂停等） crossOrigin 设置或返回音频/视频的 CORS 设置 currentSrc 返回当前音频/视频的 URL currentTime 设置或返回音频/视频中的当前播放位置（以秒计） defaultMuted 设置或返回音频/视频默认是否静音 defaultPlaybackRate 设置或返回音频/视频的默认播放速度 duration 返回当前音频/视频的长度（以秒计） ended 返回音频/视频的播放是否已结束 error 返回表示音频/视频错误状态的 MediaError 对象 loop 设置或返回音频/视频是否应在结束时重新播放 mediaGroup 设置或返回音频/视频所属的组合（用于连接多个音频/视频元素） muted 设置或返回音频/视频是否静音 networkState 返回音频/视频的当前网络状态 paused 设置或返回音频/视频是否暂停 playbackRate 设置或返回音频/视频播放的速度 played 返回表示音频/视频已播放部分的 TimeRanges 对象 preload 设置或返回音频/视频是否应该在页面加载后进行加载 readyState 返回音频/视频当前的就绪状态 seekable 返回表示音频/视频可寻址部分的 TimeRanges 对象 seeking 返回用户是否正在音频/视频中进行查找 src 设置或返回音频/视频元素的当前来源 startDate 返回表示当前时间偏移的 Date 对象 textTracks 返回表示可用文本轨道的 TextTrackList 对象 videoTracks 返回表示可用视频轨道的 VideoTrackList 对象 volume 设置或返回音频/视频的音量 4.6.3. 事件 事件 描述 abort 当音频/视频的加载已放弃时 canplay 当浏览器可以播放音频/视频时 canplaythrough 当浏览器可在不因缓冲而停顿的情况下进行播放时 durationchange 当音频/视频的时长已更改时 emptied 当目前的播放列表为空时 ended 当目前的播放列表已结束时 error 当在音频/视频加载期间发生错误时 loadeddata 当浏览器已加载音频/视频的当前帧时 loadedmetadata 当浏览器已加载音频/视频的元数据时 loadstart 当浏览器开始查找音频/视频时 pause 当音频/视频已暂停时 play 当音频/视频已开始或不再暂停时 playing 当音频/视频在已因缓冲而暂停或停止后已就绪时 progress 当浏览器正在下载音频/视频时 ratechange 当音频/视频的播放速度已更改时 seeked 当用户已移动/跳跃到音频/视频中的新位置时 seeking 当用户开始移动/跳跃到音频/视频中的新位置时 stalled 当浏览器尝试获取媒体数据，但数据不可用时 suspend 当浏览器刻意不获取媒体数据时 timeupdate 当目前的播放位置已更改时 volumechange 当音量已更改时 waiting 当视频由于需要缓冲下一帧而停止 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 获取界面上的video元素，所有的操作必须通过它实现var video = document.getElementById('video');var btn_play = document.getElementById('btn_play');// 注册点击事件// addEventListener 用于注册事件， 将事件属性的on去掉 作为第一个参数传入btn_play.addEventListener('click', function() &#123; video.play(); btn_play.disabled = true; btn_pause.disabled = false;&#125;);var btn_pause = document.getElementById('btn_pause');btn_pause.addEventListener('click', function() &#123; video.pause(); btn_play.disabled = false; btn_pause.disabled = true;&#125;);var btn_muted = document.getElementById('btn_muted');btn_muted.addEventListener('click', function() &#123; // 交互变化true或false video.muted = !video.muted; btn_muted.innerHTML = video.muted ? "取消静音" : "静音";&#125;);var volume = document.getElementById('volume');volume.addEventListener('change', function(e) &#123; // 拿一下当前volume的值 video.volume = volume.value;&#125;);var btn_speed_up = document.getElementById('btn_speed_up');btn_speed_up.addEventListener('click', function(e) &#123; // 加速 video.playbackRate += 0.1;&#125;);var btn_speed_down = document.getElementById('btn_speed_down');btn_speed_down.addEventListener('click', function(e) &#123; // 减速 video.playbackRate -= 0.1;&#125;);var btn_forward = document.getElementById('btn_forward');btn_forward.addEventListener('click', function(e) &#123; // 前进5秒 video.currentTime += 5;&#125;);var btn_back = document.getElementById('btn_back');btn_back.addEventListener('click', function(e) &#123; // 后退5秒 video.currentTime -= 5;&#125;);// 注册视频播放状态变化事件video.addEventListener('timeupdate', function() &#123; // console.log(1111); progress.value = (video.currentTime / video.duration) * 100;&#125;); 4.7. 全屏 API HTML5中提供了可以通过JS实现网页全屏的效果 具体的方式就是通过特定元素的requestFullScreen方法实现 由于在不同浏览器中该方法需要加上特定前缀 退出全屏通过exitFullScreen方法 12345678910111213141516171819// 全屏function fullScreen(element) &#123; if (element.requestFullScreen) &#123; element.requestFullScreen(); &#125; else if (element.webkitRequestFullScreen) &#123; element.webkitRequestFullScreen() &#125; else if (element.mozRequestFullScreen) &#123; element.mozRequestFullScreen() &#125; else if (element.oRequestFullScreen) &#123; element.oRequestFullScreen() &#125; else if (element.msRequestFullScreen) &#123; element.msRequestFullScreen() &#125;&#125;var btnFullScreen = document.getElementById('btn_fullscreen');btnFullScreen.addEventListener('click', function() &#123; fullScreen(video); // fullScreen(document.body);&#125;); 解决问题的思路比如何实现一个需求更重要，因为你不可能每次都遇到相同的需求 4.8. SVG 了解* iframe的作用就是在网页中挖个坑，在这个坑里再展示一个页面 svg本身也是文档 所以可以使用iframe的方式载入 5. JS 基础 API5.1. 新选择器 JavaScript在HTML5中多了一套原生选择器API 其功能类似jQuery选择器 写法上类似原本的document.getElementById(‘xxx’) 123var element1 = document.getElementById('section1'); √ 已经getvar elements2 = document.getElementsByTagName('div'); √ 已经getvar elements3 = document.getElementsByClassName('section'); 除了这种简单的类名选择器，H5中新增了很多更高级的API： 123document.querySelectorAll('ul');document.querySelectorAll('.container');document.querySelector('div#container &gt; .inner'); API 描述 返回结果 querySelector 获取第一个满足选择器条件的元素 一个DOM对象 querySelectorAll 获取所有满足选择器条件的元素 包含多个DOM对象的数组 getElementsByClassName 获取所有使用指定类名的元素 包含多个DOM对象的数组 小提示：h5大部分时候就是将我们经常需要的操作原生支持一下，让我们使用起来更方便，不用再借助第三方的框架 5.2. Element.classList H5中DOM对象多了一个classList属性 该属性其实就是是一个数组 这个数组中的内容就是当前DOM元素的每一个类 具体的操作如下： API 描述 对比jQuery element.classList.add() 给当前元素添加指定类名 $element.addClass() element.classList.remove() 在当前元素中删除指定类名 $element.removeClass() element.classList.contains() 判断当前元素中是否存在指定类名 $element.hasClass() element.classList.toggleClass() 在当前元素上切换指定类名的存在 $element.toggleClass() 5.3. 自定义属性 DATA-* ! 在HTML5中，如果想要给元素添加一些自定义属性 可以DOM对象添加一些data-xxx的属性 HTML5中data-是自定义属性的前缀 一般用来记录与当前DOM强相关的数据 123&lt;ul id="users"&gt; &lt;li data-id="1" data-age="18" data-gender="true"&gt;张三&lt;/li&gt;&lt;/ul&gt; 如果需要用JS的方式操作自定义属性，可以通过getAttribute()/setAttribute()方式 当然HTML5在JavaScript中提供了一个新的 API：dataset， 用于操作元素的自定义属性 12345678var liElement = document.querySelector('#users &gt; li');// 添加一个自定义属性liElement.dataset['name'] = '张三';// 获取liElement中所有的自定义属性console.log(liElement.dataset);// output: &#123;id: 1, age: 18, gender: true, name: '张三'&#125; 6. 离线 &amp; 存储6.1. Application CacheApplication Cache 就是让网页可以离线访问的技术 使用方式： 创建一个缓存清单文件（比如：cache.manifest） 1234567891011CACHE MANIFEST# version 1.0.7CACHE: css/style.css js/script.js img/logo.png index.htmlNETWORK: * 回到HTML中，给HTML标签添加manifest属性，指向刚刚创建的缓存清单文件 123&lt;html manifest="cache.manifest"&gt;...&lt;/html&gt; JS中可以捕获到Application Cache的更新事件： 1234567891011if (window.applicationCache) &#123; window.applicationCache.addEventListener('updateready', function(e) &#123; // 更新完成触发 if (window.applicationCache.status == window.applicationCache.UPDATEREADY) &#123; window.applicationCache.swapCache(); if (confirm('更新成功，是否刷新页面?')) &#123; window.location.reload(); &#125; &#125; &#125;);&#125; 6.2. Web StorageHTML5中提供了可以离线操作的数据存储接口： localStorage （永久，除非用户手动清除） sessionStorage （会话，关闭浏览器清除） 两者操作方式完全相同，只不过是数据存储的周期不同 1234567891011var btnSet = document.querySelector('#btn_set');var btnGet = document.querySelector('#btn_get');var txtValue = document.querySelector('#txt_value');btnGet.addEventListener('click', function() &#123; // txtValue.value = localStorage.getItem('key1'); txtValue.value = localStorage['key1'];&#125;);btnSet.addEventListener('click', function() &#123; // localStorage.setItem('key1', txtValue.value); localStorage['key1'] = txtValue.value;&#125;); getItem方式获取一个不存在的键 返回空字符串 []方式获取一个不存在的键 返回undefined 7. 文件 API input file类型，文件类型的限制 7.1. 读取本地文件信息文件域对象可以获取用户选择文件的信息： 文件名 最近修改时间 文件大小 文件类型 123456var input = document.querySelector('#input_1');var file = input.files[0];file.name // 获取文件名file.lastModifiedDate // 获取最近修改时间file.size // 获取文件大小（单位KB）file.type // 获取文件类型（如：text/plain、image/png） 7.2. 文件域改变事件7.3. 文件域样式7.4. 使用FileReader读取文件内容FileReader就是用来读取本地文件的对象 123456789var reader = new FileReader();reader.addEventListener('load', function () &#123; this.result; // 读取出来的结果&#125;);reader.readAsText(file); // 以文本的形式读取reader.readAsDataURL(file); // 以DataURI的形式读取// 以下（后台工程师用，前端不会用到）reader.readAsBinaryString(file); // 二进制格式reader.readAsArrayBuffer(file); // 字节数组 8. 拖放操作8.1. 网页内元素拖放 拖放是 HTML5 中非常常见的功能 我们可以通过在元素上添加draggable=&quot;true&quot;属性实现元素允许被拖拽 提示：链接和图片默认是可拖动的，不需要 draggable 属性。 ondrag 事件在元素或者选取的文本被拖动时触发。 在拖放的过程中会触发以下事件： 在拖动目标上触发事件 (源元素): ondragstart - 用户开始拖动元素时触发 ondrag - 元素正在拖动时触发 ondragend - 用户完成元素拖动后触发 释放目标时触发的事件（目标元素）: ondragenter - 当被鼠标拖动的对象进入其容器范围内时触发此事件 ondragover - 当某被拖动的对象在另一对象容器范围内拖动时触发此事件 ondragleave - 当被鼠标拖动的对象离开其容器范围内时触发此事件 ondrop - 在一个拖动过程中，释放鼠标键时触发此事件 注意： 在拖动元素时，每隔 350 毫秒会触发 ondrag 事件。 8.2. 拖拽删除效果 作业 8.3. 桌面文件拖拽至网页12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 找到目标位置框框var target = document.querySelector('#target');var fileList = document.querySelector('#result');// 注册拖拽进入target.addEventListener('dragenter', function() &#123; this.classList.add('actived');&#125;);// 离开target.addEventListener('dragleave', function() &#123; this.classList.remove('actived');&#125;);// 如果想要捕获drop事件 就一定得在该事件中阻止默认事件target.addEventListener('dragover', function(e) &#123; e.preventDefault(); e.stopPropagation();&#125;);// 当元素放到该对象上target.addEventListener('drop', function(e) &#123; if (e.dataTransfer.files.length) &#123; var files = e.dataTransfer.files; for (var i = 0; i &lt; files.length; i++) &#123; var li = document.createElement('li'); li.setAttribute('class', 'list-group-item'); // 创建信息的子节点 li.innerHTML = '&lt;h5 class="list-group-item-heading"&gt;' + files[i].name + '&lt;/h5&gt;&lt;p class="list-group-item-text"&gt;' + files[i].lastModifiedDate.toLocaleDateString() + ' ' + files[i].lastModifiedDate.toLocaleTimeString() + ' ' + (files[i].size / 1024).toFixed(2) + 'KB&lt;/p&gt;'; fileList.appendChild(li); &#125; &#125; else &#123; // 短路运算 // var data = e.dataTransfer.getData('text/plain') || e.dataTransfer.getData('text/uri-list'); var data = e.dataTransfer.getData('text/plain'); if (data) &#123; // 拖入的是文本 target.innerHTML = data; &#125; else &#123; var img = document.createElement('img'); img.src = e.dataTransfer.getData('text/uri-list'); target.appendChild(img); &#125; &#125; this.classList.remove('actived'); e.preventDefault(); e.stopPropagation();&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Bower常用命令]]></title>
      <url>%2Fblog%2F2016%2F11%2F03%2Fbower-md%2F</url>
      <content type="text"><![CDATA[12345678910111213141516$ # 初始化一个Bower的配置文件$ bower init$ # 安装一个包$ bower install bootstrap$ # GitHub shorthand$ bower install desandro/masonry$ # Git endpoint$ bower install git://github.com/user/package.git$ # URL$ bower install http://example.com/script.js$ # 安装一个包并将其添加到配置文件$ bower install bootstrap --save$ # 卸载一个包$ bower uninstall bootstrap$ # 更新所有的包$ bower update Bower配置文件 项目根目录 用户主目录]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git 基本命令]]></title>
      <url>%2Fblog%2F2016%2F11%2F03%2Fgit-md%2F</url>
      <content type="text"><![CDATA[5.3.1.初始化一个本地GIT仓储1234// 定位到仓储文件夹目录$ cd /dir// 初始化本地仓储$ git init 5.3.2.添加本地GIT忽略清单文件.gitignore12// 添加OS X中系统文件.DS_Store到忽略清单，这将忽略项目任意目录下的.DS_Store文件或是文件夹$ echo .DS_Store &gt;&gt; .gitignore 5.3.3.查看本地仓储的变更状态1$ git status 5.3.4.添加本地暂存（托管）文件123456// 添加指定文件名的文件$ git add README.md// 添加通配符匹配的文件$ git add *.md// 添加所有未托管的文件（忽略.gitignore清单中的列表）$ git add --all 5.3.5.提交被托管的文件变化到本地仓储1$ git commit -m &apos;Initial commit(change log)&apos; 5.3.6.为仓储添加远端（服务器端）地址1234// 添加一个远端地址并起了一个别名叫origin$ git remote add origin https://github.com/Micua/Git.git// 查看现有的远端列表$ git remote -v 5.3.7.将本地仓储的提交记录推送到远端的master分支1$ git push -u origin master 5.3.8.拉取远端master分支的更新记录到本地1$ git pull origin master]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Gulp入门]]></title>
      <url>%2Fblog%2F2016%2F10%2F25%2Fglup-first%2F</url>
      <content type="text"><![CDATA[当下的前端开发 不再是简简单单的使用HTML+CSS+JavaScript这些简单的技术构建网页应用程序了 我们要提高效率，就必须减少重复的工作 使用less之类预处理的CSS coffeescript 提供开发阶段的便利，开发阶段更快捷 现在的开发行业优质的开发人员是不应该将精力放在这些重复性质的工作上 Gulp就是一种可以自动化完成我们开发过程中大量的重复工作 预处理语言的编译 js css html 压缩混淆 图片体积优化 除gulp之外还有一些类似的自动化工具，比如grunt what how why Gulp简介 当下最流行的自动化工具 什么是自动化构建工具？ 自动完成一系列重复的操作 less → css coffeescript → js css压缩 js混淆 html压缩 img尺寸优化 。。。。 链接： 官网 中文网 gulp的包既包含工具，也包含一些编程的API 准备工作 安装Node.js Node.js 给前端带来了一场工业革命 http://npm.taobao.org/ 安装完成过后可以通过命令行工具node -v 安装nodejs过程会自动安装npm(node packages manager) npm 3 以前的版本文件依赖是层级依赖 npm 3 以后依赖关系改为平行依赖（windows上路径过长问题） gulp本身是node的模块 安装 gulp 命令行工具 npm install -g gulp -g 指的是在全局作用域中安装 测试命令 gulp -v 初始化 gulp 项目 在本地安装gulp包 npm install gulp –save 创建任务 - gulpfile.js gulpfile.js 就是gulp的主文件 基本使用 定义一个任务 复制单个文件 复制多个文件 globs匹配语法 src/* src/*/* src/**/* src/*.jpg src/*.{jpg,png} 多个globs [‘src/*.{jpg,png}’,’a/a.html’] 排除某些文件 !xxxxx 默认任务 gulp 中的任务名有个特殊值 default 文件监视自动执行任务 常用插件 编译 Less：gulp-less 编译 Jade: gulp-jade 创建本地服务器：gulp-connect 合并文件：gulp-concat 最小化 js 文件：gulp-uglify 重命名文件：gulp-rename 最小化 css 文件：gulp-minify-css 压缩html文件 gulp-minify-html 最小化图像：gulp-imagemin]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[gulp demo]]></title>
      <url>%2Fblog%2F2016%2F10%2F25%2Fglup-demo%2F</url>
      <content type="text"><![CDATA[//1. LESS编译 压缩 合并 //2. JS合并 压缩 混淆 //3. img复制 //4. html压缩 ‘use strict’;// 在gulpfile中先载入gulp包，因为这个包提供了一些APIvar gulp = require(‘gulp’);var less = require(‘gulp-less’);var cssnano = require(‘gulp-cssnano’); // 1. LESS编译 压缩 –合并没有必要，一般预处理CSS都可以导包gulp.task(‘style’, function() { // 这里是在执行style任务时自动执行的 gulp.src([‘src/styles/.less’, ‘!src/styles/_.less’]) .pipe(less()) .pipe(cssnano()) .pipe(gulp.dest(‘dist/styles’)) .pipe(browserSync.reload({ stream: true }));}); var concat = require(‘gulp-concat’);var uglify = require(‘gulp-uglify’); // 2. JS合并 压缩混淆gulp.task(‘script’, function() { gulp.src(‘src/scripts/*.js’) .pipe(concat(‘all.js’)) .pipe(uglify()) .pipe(gulp.dest(‘dist/scripts’)) .pipe(browserSync.reload({ stream: true }));}); // 3. 图片复制gulp.task(‘image’, function() { gulp.src(‘src/images/.‘) .pipe(gulp.dest(‘dist/images’)) .pipe(browserSync.reload({ stream: true }));}); var htmlmin = require(‘gulp-htmlmin’);// 4. HTMLgulp.task(‘html’, function() { gulp.src(‘src/*.html’) .pipe(htmlmin({ collapseWhitespace: true, removeComments: true })) .pipe(gulp.dest(‘dist’)) .pipe(browserSync.reload({ stream: true }));}); var browserSync = require(‘browser-sync’);gulp.task(‘serve’, function() { browserSync({ server: { baseDir: [‘dist’] }, }, function(err, bs) { console.log(bs.options.getIn([“urls”, “local”])); }); gulp.watch(‘src/styles/.less’,[‘style’]); gulp.watch(‘src/scripts/.js’,[‘script’]); gulp.watch(‘src/images/.‘,[‘image’]); gulp.watch(‘src/*.html’,[‘html’]);});]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[bootstrap微金所项目实战]]></title>
      <url>%2Fblog%2F2016%2F10%2F25%2Fbootstrap-second%2F</url>
      <content type="text"><![CDATA[微金所项目实战1. 搭建Bootstrap页面骨架及项目目录结构12345678├─ /weijinsuo/ ··················· 项目所在目录└─┬─ /css/ ······················· 我们自己的CSS文件 ├─ /font/ ······················ 使用到的字体文件 ├─ /img/ ······················· 使用到的图片文件 ├─ /js/ ························ 自己写的JS脚步 ├─ /lib/ ······················· 从第三方下载回来的库【只用不改】 ├─ /favicon.ico ················ 站点图标 └─ /index.html ················· 入口文件 1.1.约定编码规范1.1.1.HTML约定 在head中引入必要的CSS文件，优先引用第三方的CSS，方便我们自己的样式覆盖 在body末尾引入必要的JS文件，优先引用第三方的JS，注意JS文件之间的依赖关系，比如bootstrap.js依赖jQuery，那就应该先引用jquery.js 然后引用bootstrap.js 1.1.2.CSS约定 除了公共级别样式，其余样式全部由 模块前缀 尽量使用 直接子代选择器， 少用间接子代 避免错杀 1.2.HTML5文档结构12345678910&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;页面标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 1.3.Viewport设置1&lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0"&gt; html中插入视口设置，可以通过emmet meta:vp 插入 1.4.浏览器兼容模式1&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; html中插入兼容模式设置，可以通过emmet meta:compat 插入 1.5.favicon（站点图标）1&lt;link rel="shortcut icon" type="image/x-icon" href="favicon.ico"&gt; html中插入图标链接，可以通过emmet link:favicon 插入 1.6.引入相应的第三方文件123456&lt;link rel="stylesheet" href="bootstrap.css"&gt;&lt;link rel="stylesheet" href="my.css"&gt;...&lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;script src="bootstrap.js"&gt;&lt;/script&gt;&lt;script src="my.js"&gt;&lt;/script&gt; 1.7.在我们默认的样式表中将默认字体设置为：12345678body&#123; font-family: "Helvetica Neue", Helvetica, Microsoft Yahei, Hiragino Sans GB, WenQuanYi Micro Hei, sans-serif;&#125; 2.完成页面空结构 先划分好页面中的大容器，然后在具体看每一个容器中单独的情况 1234567891011121314151617181920212223242526&lt;body&gt; &lt;!-- 头部区域 --&gt; &lt;header&gt;&lt;/header&gt; &lt;!-- /头部区域 --&gt; &lt;!-- 广告轮播 --&gt; &lt;section&gt;&lt;/section&gt; &lt;!-- /广告轮播 --&gt; &lt;!-- 特色介绍 --&gt; &lt;section&gt;&lt;/section&gt; &lt;!-- /特色介绍 --&gt; &lt;!-- 立即预约 --&gt; &lt;section&gt;&lt;/section&gt; &lt;!-- /立即预约 --&gt; &lt;!-- 产品推荐 --&gt; &lt;section&gt;&lt;/section&gt; &lt;!-- /产品推荐 --&gt; &lt;!-- 新闻列表 --&gt; &lt;section&gt;&lt;/section&gt; &lt;!-- /新闻列表 --&gt; &lt;!-- 合作伙伴 --&gt; &lt;section&gt;&lt;/section&gt; &lt;!-- /合作伙伴 --&gt; &lt;!-- 脚注区域 --&gt; &lt;footer&gt;&lt;/footer&gt; &lt;!-- /脚注区域 --&gt;&lt;/body&gt; 3.构建顶部通栏123&lt;header&gt; &lt;div class="topbar"&gt;&lt;/div&gt;&lt;/header&gt; 3.1.container类 用于定义一个固定宽度且居中的版心 12345678&lt;div class="topbar"&gt; &lt;div class="container"&gt; &lt;!-- 此处的代码会显示在一个固定宽度且居中的容器中 该容器的宽度会跟随屏幕的变化而变化 --&gt; &lt;/div&gt;&lt;/div&gt; 3.2.栅格系统 Bootstrap中定义了一套响应式的网格系统， 其使用方式就是将一个容器划分成12列， 然后通过col-xx-xx的类名控制每一列的占比 3.2.1.row类 因为每一个列默认有一个15px的左右外边距 row类的一个作用就是通过左右-15px屏蔽掉这个边距 123&lt;div class="container"&gt; &lt;div class="row"&gt;&lt;/div&gt;&lt;/div&gt; 3.2.2.col-\-*类 col-xs-[列数]：在超小屏幕下展示几份 col-sm-[列数]：在小屏幕下展示几份 col-md-[列数]：在中等屏幕下展示几份 col-lg-[列数]：在大屏幕下展示几份 xs : 超小屏幕 手机 (&lt;768px) sm : 小屏幕 平板 (≥768px) md : 中等屏幕 桌面显示器 (≥992px) lg : 大屏幕 大桌面显示器 (≥1200px) 123456&lt;div class="row"&gt; &lt;div class="col-md-2 text-center"&gt;&lt;/div&gt; &lt;div class="col-md-5 text-center"&gt;&lt;/div&gt; &lt;div class="col-md-2 text-center"&gt;&lt;/div&gt; &lt;div class="col-md-3 text-center"&gt;&lt;/div&gt;&lt;/div&gt; 此处顶部通栏已经被划分成四列text-center的作用就是让内部内容居中显示 3.2.字体图标12345678910111213141516@font-face &#123; font-family: 'itcast'; src: url('../font/MiFie-Web-Font.eot') format('embedded-opentype'), url('../font/MiFie-Web-Font.svg') format('svg'), url('../font/MiFie-Web-Font.ttf') format('truetype'), url('../font/MiFie-Web-Font.woff') format('woff');&#125;[class^="icon-"],[class*=" icon-"] &#123; /*注意上面选择器中间的空格*/ /*我们使用的名为itcast的字体就是上面的@font-face的方式声明的*/ font-family: itcast; font-style: normal;&#125;.icon-mobilephone::before&#123; content: '\e908';&#125; 123456789&lt;div class="col-md-2 text-center"&gt; &lt;a class="mobile-link" href="#"&gt; &lt;i class="icon-mobile"&gt;&lt;/i&gt; &lt;span&gt;手机微金所&lt;/span&gt; &lt;!-- 这里使用的是bootstrap中的字体图标 --&gt; &lt;i class="glyphicon glyphicon-chevron-down"&gt;&lt;/i&gt; &lt;img src="..." alt=""&gt; &lt;/a&gt;&lt;/div&gt; 字体文件格式 eot : embedded-opentype svg : svg ttf : truetype woff : woff 3.4.hover图片展示123.mobile-link:hover &gt; img &#123; display: block;&#125; 3.5.按钮样式生成 http://blog.koalite.com/bbg/ 可以通过界面生成一个新的按钮样式 123456789101112131415161718192021222324252627282930313233343536373839404142434445.btn-itcast &#123; color: #ffffff; background-color: #E92322; border-color: #DB3B43;&#125;.btn-itcast:hover,.btn-itcast:focus,.btn-itcast:active,.btn-itcast.active,.open .dropdown-toggle.btn-itcast &#123; color: #ffffff; background-color: #E92322; border-color: #DB3B43;&#125;.btn-itcast:active,.btn-itcast.active,.open .dropdown-toggle.btn-itcast &#123; background-image: none;&#125;.btn-itcast.disabled,.btn-itcast[disabled],fieldset[disabled] .btn-itcast,.btn-itcast.disabled:hover,.btn-itcast[disabled]:hover,fieldset[disabled] .btn-itcast:hover,.btn-itcast.disabled:focus,.btn-itcast[disabled]:focus,fieldset[disabled] .btn-itcast:focus,.btn-itcast.disabled:active,.btn-itcast[disabled]:active,fieldset[disabled] .btn-itcast:active,.btn-itcast.disabled.active,.btn-itcast[disabled].active,fieldset[disabled] .btn-itcast.active &#123; background-color: #E92322; border-color: #DB3B43;&#125;.btn-itcast .badge &#123; color: #E92322; background-color: #ffffff;&#125; 3.5小屏幕隐藏1&lt;div class="topbar hidden-xs hidden-sm"&gt;&lt;/div&gt; 或者 1&lt;div class="topbar visible-md visible-lg"&gt;&lt;/div&gt; hidden-xx : 在某种屏幕下隐藏 visible-xx : 在某种屏幕尺寸下显示 visible-xx-xx：最后一个xx是决定显示时的display到底是啥 4.导航通栏 在使用了boostrap过后，大多数界面元素都是通过bootstrap提供好的界面组件修改得来 1234567891011121314151617181920212223242526272829&lt;nav class="navbar navbar-itcast navbar-static-top"&gt; &lt;div class="container"&gt; &lt;div class="navbar-header"&gt; &lt;button id="btn" type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#nav_list" aria-expanded="false"&gt; &lt;span class="sr-only"&gt;切换菜单&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class="navbar-brand" href="#"&gt; &lt;i class="icon-icon"&gt;&lt;/i&gt; &lt;i class="icon-logo"&gt;&lt;/i&gt; &lt;/a&gt; &lt;/div&gt; &lt;div id="nav_list" class="collapse navbar-collapse"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;我要投资&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;我要借款&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;平台介绍&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;新手专区&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;最新动态&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;微论坛&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class="nav navbar-nav navbar-right hidden-sm"&gt; &lt;li&gt;&lt;a href="#"&gt;个人中心&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/nav&gt; 4.1.Bootstrap扩展 通过bootstrap文档对导航条样式的设置发现，其实本身是有一个类似于主题的概念 navbar-default：默认的外观 navbar-inverse：暗色背景的样式 所以我们希望可以通过自定义一套完整的风格： navbar-itcast 1234.navbar-itcast&#123; ...&#125;...具体代码参考navbar-default实现即可 4.2.品牌logo 任然使用字体图标 4.3.菜单行高调整 默认样式中菜单的行高为20px，我们可以调整为自己想要的高度 一般都是通过自己的样式去覆盖 5.轮播图5.1.Bootstrap JS插件使用 在一个较小屏幕下展示一个超宽的图片，想让图片居中显示 背景图 p-a l 50% m-l -width/2 5.2.background使用5.2.1.background-size length 如100px 100px percentage 如90% 90% cover 背景图片的较小边放大到目标大小结束 contain 相反 5.3.图片响应式 目的 各种终端都需要正常显示图片 移动端应该使用更小（体积）的图片 实现方式 5.4.window resize事件6.网站特性6.1.网格系统6.2.媒体对象样式6.3.响应式辅助类型- hidden-xx 7.预约投标7.1.pull-left7.2.pull-right8.投资产品8.1.Tab选项卡8.2.网格系统8.3.::before8.4.::after8.5.tooltip插件9.新闻资讯9.1.Tab选项卡9.2.响应式偏移10.合作伙伴10.1.相邻兄弟选择器11.登录对话框11.1模态框11.2表单样式12.导航吸顶12.1affix组件13.深度自定义13.1.http://v3.bootcss.com/customize13.2通过 Less 文件修改14.version 4http://www.cnblogs.com/micua/p/bootstrap-version4-alpha.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Bootstrap入门]]></title>
      <url>%2Fblog%2F2016%2F10%2F25%2Fbootstrap-first%2F</url>
      <content type="text"><![CDATA[简介什么是Bootstrap？ 框架：库 lib library jQuery作为一个框架来讲，提供一套比较便捷的操作DOM的方式 把大家都需要的功能预先写好到一些文件 这就是一个框架 Bootstrap 让我们的 Web 开发更简单，更快捷； 注意是 Bootstrap 不是 BootStrap！这是一个词，不是合成词，其含义为：n. 引导指令,引导程序 Bootstrap 是当下最流行的前端框架（界面工具集）； 特点就是灵活简洁，代码优雅，美观大方； 其目的是为了让 Web 开发更敏捷； 是 Twitter 公司的两名前端工程师 Mark Otto 和 Jacob Thornton 在 2011 - 年发起的，并利用业余时间完成第一个版本的开发； 为什么使用Bootstarp？ 生态圈火，不断地更新迭代； 提供一套美观大方地界面组件； 提供一套优雅的 HTML+CSS 编码规范； 让我们的 Web 开发更简单，更快捷； 注意： 使用 Bootstrap 并不代表不用写 CSS 样式，而是不用写绝大多数大家都会用到的样式 准备下载Bootstrap https://github.com/twbs/bootstrap/releases/download/v3.3.6/bootstrap-3.3.6-dist.zip https://github.com/twbs/bootstrap/releases/download/v4.0.0-alpha.2/bootstrap-4.0.0-alpha.2-dist.zip 安装Bootstrap1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;页面标题&lt;/title&gt; &lt;!-- 引入Bootstrap核心样式文件（必须） --&gt; &lt;link rel="stylesheet" href="css/bootstrap.min.css"&gt; &lt;!-- 引入Bootstrap默认主题样式（可选） --&gt; &lt;link rel="stylesheet" href="css/bootstrap.theme.min.css"&gt; &lt;!-- 你自己的样式或其他文件 --&gt; &lt;link rel="stylesheet" href="example.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 你的HTML结构...... --&gt; &lt;!-- 以下代码，如果不使用JS插件则不需要 --&gt; &lt;!-- 由于Bootstrap的JS插件依赖jQuery，so 引入jQuery --&gt; &lt;script src="js/jquery.min.js"&gt;&lt;/script&gt; &lt;!-- 引入所有的Bootstrap的JS插件 --&gt; &lt;script src="bootstrap.min.js"&gt;&lt;/script&gt; &lt;!-- 你自己的脚本文件 --&gt; &lt;script src="example.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Bootstrap文档 官方文档 中文文档 基础的Bootstrap模板1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags --&gt; &lt;title&gt;Bootstrap 101 Template&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;link href="css/bootstrap.min.css" rel="stylesheet"&gt; &lt;!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries --&gt; &lt;!-- WARNING: Respond.js doesn't work if you view the page via file:// --&gt; &lt;!--[if lt IE 9]&gt; &lt;script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"&gt;&lt;/script&gt; &lt;script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;!-- jQuery (necessary for Bootstrap's JavaScript plugins) --&gt; &lt;script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"&gt;&lt;/script&gt; &lt;!-- Include all compiled plugins (below), or include individual files as needed --&gt; &lt;script src="js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Compatible1&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; 此属性为文档兼容模式声明，表示如果在IE浏览器下则使用最新的标准渲染当前文档 视口1&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; 视口的作用：在移动浏览器中，当页面宽度超出设备，浏览器内部虚拟的一个页面容器，将页面容器缩放到设备这么大，然后展示 目前大多数手机浏览器的视口（承载页面的容器）宽度都是980； 视口的宽度可以通过meta标签设置 此属性为移动端页面视口设置，当前值表示在移动端页面的宽度为设备的宽度，并且不缩放（缩放级别为1） width:视口的宽度 initial-scale：初始化缩放 user-scalable:是否允许用户自行缩放（值：yes/no; 1/0） minimum-scale:最小缩放，一般设置了用户不允许缩放，就没必要设置最小和最大缩放 maximum-scale:最大缩放 条件注释 条件注释的作用就是当判断条件满足时，就会执行注释中的HTML代码，不满足时会当做注释忽略掉 第三方依赖 jQuery Bootstrap框架中的所有JS组件都依赖于jQuery实现 html5shiv 让低版本浏览器可以识别HTML5的新标签，如header、footer、section等 respond 让低版本浏览器可以支持CSS媒体查询功能 建议以后在HTML中将脚步的引入放到页面最底下mediaquery12345678910@media (判断条件（针对于当前窗口的判断）)&#123; /*这里的代码只有当判断条件满足时才会执行*/&#125;@media (min-width: 768px) and (max-width: 992px) &#123; /*这里的代码只有当(min-width: 1280px)满足时才会执行*/ .container &#123; width: 750px; &#125;&#125; 当使用min-width作为判断条件一定要从小到大，其原因是CSS从上往下执行 基础CSS样式 概要 + 预置排版样式 统一预制标签样式 按钮样式 + 表格样式 + 表单样式 + 图片样式 + 辅助工具类 + 代码样式 + 栅格系统 xs : 超小屏幕 手机 (&lt;768px) sm : 小屏幕 平板 (≥768px) md : 中等屏幕 桌面显示器 (≥992px) lg : 大屏幕 大桌面显示器 (≥1200px) 响应式工具类 hidden-xx : 在某种屏幕下隐藏 visible-xx : 在某种屏幕尺寸下显示 预置界面组件 导航 导航条 面包屑导航 下拉菜单 按钮式下拉菜单 按钮组 输入框组 警告框 页头 分页 列表组 面板 媒体对象 进度条 Glyphicons 标签 徽章 缩略图 大屏幕 嵌入内容 内嵌 JavaScript插件JavaScript插件的依赖情况如何使用Javascript插件内置组件 模态对话框 下拉菜单 滚动监听 标签页 工具提示 弹出框 警告框 按钮 折叠面板 轮播图 吸顶效果 data-spy=”affix” data-offset-top=”什么位置出现” data-offset-bottom=”什么位置消失” 深度自定义 Bootstrap在线自定义 官网在线 中文网在线 源码编译LESS语言 官方文档 中文文档]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[流行框架第三天：Angular入门]]></title>
      <url>%2Fblog%2F2016%2F10%2F25%2Fnode-first%2F</url>
      <content type="text"><![CDATA[Node服务器端开发第一天 Node简介及配置、快速上手、核心特点、模块化 Node简介客户端的JavaScript是怎样的 什么是 JavaScript？ 脚本语言 运行在浏览器中 一般用来做客户端页面的交互（Interactive） JavaScript 的运行环境？ 是不是运行在浏览器呢？ 不够严谨 运行在浏览器内核中的 JS 引擎（engine） 浏览器中的 JavaScript 可以做什么？ 操作DOM（对DOM的增删改、注册事件） AJAX/跨域 BOM（页面跳转、历史记录、console.log()、alert()） ECMAScript 浏览器中的 JavaScript 不可以做什么？ 文件操作（文件和文件夹的CRUD） 没有办法操作系统信息 由于运行环境特殊（我们写的代码是在不认识的人的浏览器中运行） 在开发人员能力相同的情况下编程语言的能力取决于什么？ -语言本身？- 语言本身只是提供定义变量，定义函数，定义类型，流程控制，循环结构之类的操作 取决于运行该语言的平台（环境） 对于JS来说，我们常说的JS实际是ES，大部分能力都是由浏览器的执行引擎决定 BOM和DOM可以说是浏览器开放出来的接口 比如：Cordova中提供JS调用摄像头，操作本地文件的API Java既是语言也是平台 Java运行在Java虚拟机（跨操作系统） PHP既是语言也是平台（跨操作系统） C#语言平台：.NET Framework（Windows） C#可以运行在MONO这样的平台 因为有人需要将C#运行在Linux平台，所有出现了MONO JavaScript 只可以运行在浏览器中吗？ 不是 能运行在哪取决于，这个环境有没有特定平台 什么是Node Node 就是 JavaScript 语言在服务器端的运行环境 所谓“运行环境（平台）”有两层意思： 首先，JavaScript 语言通过 Node 在服务器运行，在这个意义上，Node 有点像 JavaScript 虚拟机； 其次，Node 提供大量工具库，使得 JavaScript 语言与操作系统互动（比如读写文件、新建子进程），在这个意义上， Node 又是 JavaScript 的工具库。 为什么是JavaScriptNode的实现结构Node在当下Web开发领域的应用哪些公司在用重点理解 Node是一个JavaScript的运行环境（平台），不是一门语言，也不是JavaScript的框架； Node的实现结构； Node可以用来开发服务端应用程序，Web系统； 基于Node的前端工具集 环境配置安装包的方式安装 安装包下载链接： Mac OSX： darwin Windows： x64 x86 安装操作： 一路Next 更新版本 操作方式： 重新下载最新的安装包； 覆盖安装即可； 问题： 以前版本安装的很多全局的工具包需要重新安装 无法回滚到之前的版本 无法在多个版本之间切换（很多时候我们要使用特定版本） NVM工具的使用 Node Version Manager（Node版本管理工具） 由于以后的开发工作可能会在多个Node版本中测试，而且Node的版本也比较多，所以需要这么款工具来管理 安装操作步骤 下载：nvm-windows 解压到一个全英文路径 编辑解压目录下的settings.txt文件（不存在则新建） root 配置为当前 nvm.exe 所在目录 path 配置为 node 快捷方式所在的目录 arch 配置为当前操作系统的位数（32/64） proxy 不用配置 配置环境变量 可以通过 window+r : sysdm.cpl NVM_HOME = 当前 nvm.exe 所在目录 NVM_SYMLINK = node 快捷方式所在的目录 PATH += %NVM_HOME%;%NVM_SYMLINK%; 打开CMD通过set [name]命令查看环境变量是否配置成功 PowerShell中是通过dir env:[name]命令 NVM使用说明： https://github.com/coreybutler/nvm-windows/ NPM的目录之后使用再配置 配置Python环境 Node中有些第三方的包是以C/C++源码的方式发布的，需要安装后编译确保全局环境中可以使用python命令 环境变量的概念 环境变量就是操作系统提供的系统级别用于存储变量的地方 Windows中环境变量分为系统变量和用户变量 环境变量的变量名是不区分大小写的 特殊值： PATH 变量：只要添加到 PATH 变量中的路径，都可以在任何目录下搜索 Windows下常用的命令行操作 切换当前目录（change directory）：cd 创建目录（make directory）：mkdir 查看当前目录列表（directory）：dir 别名：ls（list） 清空当前控制台：cls 别名：clear 删除文件：del 别名：rm 注意：所有别名必须在新版本的 PowerShell 中使用 快速上手 事件驱动和非阻塞 模块化开发]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[流行框架第三天：Angular入门]]></title>
      <url>%2Fblog%2F2016%2F10%2F24%2Fangular-first%2F</url>
      <content type="text"><![CDATA[推荐工具 在线编辑器 http://codepen.io/ https://jsfiddle.net/ Angular 简介什么是 AngularJS 一款非常优秀的前端高级 JS 框架 最早由 Misko Hevery 等人创建 2009 年被 Google 公式收购，用于其多款产品 目前有一个全职的开发团队继续开发和维护这个库 有了这一类框架就可以轻松构建 SPA 应用程序 轻松构建 SPA（单一页面应用程序） 单一页面应用程序： 只有一个页面（整个应用的一个载体） 内容全部是由AJAX方式呈现出啦的 其核心就是通过指令扩展了 HTML，通过表达式绑定数据到 HTML。 为什么使用 AngularJS 更少的代码，实现更强劲的功能 将一些以前在后台开发中使用的思想带入前端开发 带领当前市面上的框架走向模式化或者架构化 AngularJS 的核心特性 MVC 模块化 自动化双向数据绑定 指令系统 相关链接 http://www.apjs.net/ http://www.angularjs.cn/ http://docs.angularjs.cn/api https://material.angularjs.org http://angular-ui.github.io/ Angular 上手安装 Angular 下载 Angular.js 的包 https://github.com/angular/angular.js/releases 使用 CDN 上的 Angular.js http://apps.bdimg.com/libs/angular.js/1.4.9/angular.min.js 使用 Bower 安装 1bower install angular 使用 NPM 安装 1npm install angular 每种方式安装包，本质都是将angular的库下载到当前文件夹中 简单示例12 angular中最重要的概念是指令（directive） ng-model 是双向数据绑定的指令，效果就是将当前元素的value属性和模型中的user.name建立绑定关系 JS: BOM DOM ES 分析 Angular 示例使用总结运行官方文档CDN的优势Content Dev 快 节省自己服务器的带宽压力和流量 Angular 基础概念MVC 思想什么是 MVC 思想 将应用程序的组成划分为三个部分：Model View Controller 控制器的作用就是初始化模型用的； 模型就是用于存储数据的 视图用于展现数据 登陆案例 模型 我们数据库中所有用户的信息 接受控制器传来的用户名和密码进行校验的业务逻辑并返回true/false 控制器 接受用户在界面上填写的用户名和密码 将用户名和密码交给模型 视图 给用户呈现一个表单 接受用户输入内容，并将其提交给控制器 根据控制器返回的数据，响应用户页面 模块（Module） 划分应用程序结构 我们可以通过angular.module创建一个模块 angular.module方法传递两个参数才是创建模块，一个参数是获取模块 控制器（Controller） 通过$scope和视图关联 视图模型（$scope）表达式（Expression）单向数据绑定双向数据绑定Angular 指令系统]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[流行框架第二天：Git与Angular入门]]></title>
      <url>%2Fblog%2F2016%2F10%2F24%2Fgit-second%2F</url>
      <content type="text"><![CDATA[复习 Node Node.js — 类似一个操作系统 一个JS的运行环境 主要用于开发Web应用程序（回想登陆的例子） 很多的前端开发工具都是基于node这个平台 所用的工具就相当于一些软件 NVM （可选的） Node Version Manager(Node的版本管理工具) 因为node的版本比较多，很多时候我们可能依赖多个版本，并要求自由切换 使用 nvm use [对应的版本号] [平台架构（如果是32系统需要写32,64位不用管）] nvm install [arch] 安装 nvm uninstall 卸载 nvm list 查看已经安装版本 官网 https://github.com/coreybutler/nvm-windows NPM node package manager(node的包管理工具) npm管理包非常方便，我们只需要记住使用哪个包就可以了 使用 npm install xxx 安装一个包到项目本地，必须要联网 安装完成过后项目根目录下会多一个node_modules文件夹，所有的下载下来的包全部在里面 由于需要记录项目依赖哪些东西，所以需要一个配置文件“package.json”，可以通过npm init命令生成 以后安装包的时候将其–save –save就是将我们安装的包名字和包版本记录到配置文件中的dependencies节点中 –save-dev 项目依赖分两种，一个就是普通的项目依赖比如bootstrap，还用一种只是开发阶段需要用的，这种属于开发依赖比如gulp，开发依赖最终记录在devDependencies节点里面 npm uninstall xxx –save npm install xxx -g(全局安装包) 如果你安装的是一个工具，工具要在每一个地方都能用，这种情况下一般全局安装。 Bower Web sites are made of lots of things ― frameworks, libraries, assets, and utilities. Bower manages all these things for you. Bower就是用来管理项目中所有的依赖，主要用于Web页面开发时使用的包管理，比如jquery，bootstrap 重复的轮子太多，抓住轮子与轮子之间的共性 Gulp FIS3 http://www.ydcss.com/archives/94 msi - microsoft installer 微软安装器 GIT什么是GIT 是一个源代码管理工具 在一个项目中，凡是由开发人员编写的都算是源代码 源代码有必要管理起来？ 让源代码可以被追溯，主要记录每次变更了什么，谁主导这次变化 人为的维护比较麻烦， GIT是Linux之父当年为了维护管理Linux的源代码写的一个工具 Git 之前 很多使用 svn vss tfs hs …… https://guides.github.com/ 安装GIT git命令行工具 基于git命令行的一个客户端软件（提供一个界面去管理源代码） GIT命令操作 初始化一个本地GIT仓储 12cd 当前项目目录git init // 初始化一个本地的仓库 就是在本地文件夹中添加了一个.git的文件夹用于记录所有的项目变更信息 查看本地仓储的变更状态 git status用于查看本地仓储的状态第一次查看，显示的是一坨没有被跟踪的文件 git status -s // -s 是输出简要的变更日志 添加本地暂存（托管）文件 git add可以将一个没有被跟踪的文件添加到跟踪列表 类似于node_modules这种性质的文件是不应该被跟踪 添加本地GIT忽略清单文件 在代码库文件夹的根目录添加一个.gitignore文件此文件用于说明忽略的文件有哪些 提交被托管的文件变化到本地仓储 git commit将本地的变化提交的本地的仓库文件夹归档一般在有了一个小单元的整体变化后再提交 对比差异 git diff可以用于对比当前状态和版本库中状态的变化 提交日志 git log可以查看提交日志 回归到指定版本 git reset –hard 为仓储添加远端（服务器端）地址 将本地仓储的提交记录推送到远端的master分支 拉取远端master分支的更新记录到本地 回归到指定版本 GITHUB基本使用 https://github.com/ GITHUB是一个GIT服务的提供商， 提出社交化编程 http://zoomzhao.github.io/code-guide/https://github.com/jobbole/awesome-javascript-cnhttps://github.com/jobbole/awesome-css-cn GIT分支 Angular入门简介 知识储备 什么是Angular 快速构建Web应用程序 单页面应用程序 Angular的特性 为什么要用Angular 让Web应用程序开发更简单，更快捷 带领前端进入MV*的时代 开始使用 引用Angular 下载 bower npm 基本使用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[构建前端自动化工作流环境]]></title>
      <url>%2Fblog%2F2016%2F10%2F24%2Fgit-guid%2F</url>
      <content type="text"><![CDATA[学习目标 了解什么是Node，什么是NPM；（Node.js） 掌握Bower的使用； 熟练使用Less/Sass； 搭建一个自己的自动化工作流环境； 自动编译 自动合并 自动刷新 自动部署 GIT 与 GITHUB master 托管源文件 gh-pages 托管部署文件 在github搭建自己的blog 为什么要有自动化的流程 在我们的开发过程中有大量的重复操作 DRY Don’t repeat yourself 开发人员的精力应放在哪？创造，新的一切 前端开发的编译操作 1.Node环境1.1.什么是Node Node.js 可能类似jquery.js 不是JS文件，也不是一个JS框架（） 而是Server side Javascript runtime, 服务端的一个JS运行时 我们可以在NODE运行JS代码 alert();ECMAScript JS- ES BOM DOM node中只能运行ECMAScript，无法使用 BOM 和 DOM 目前我们的JS是运行在浏览器内核中 PHP是什么？是一门脚本语言也是一个运行环境 为什么Node选中了JS， 说到底就是一个JS运行环境 目前有两个分支 Node.js 0.12.7 官方版本 要求尽善尽美 IO.js 是社区的产物，不是官方的东西，io.js有很多新特性，迭代非常快，社区推进非常快 15年两者合并，发布node第一个正式版 4.0， 迭代速度又慢了 node 5.x == io.js node 4.0 == node 1.2.Node环境搭建1.2.1.Mac 安装包的方式 pkg NVM（Node Version Manager） 1234$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.30.2/install.sh | bash$ echo '. ~/.nvm/nvm.sh' &gt;&gt; .bash_profile$ nvm install stable$ nvm alias default stable 1.2.2.Windows 安装包的方式 msi_x64 msi_x86 NVM（Node Version Manager） nvm(node version manager) 因为NODE版本比较多，开发人员可能依赖很多版本 通过NVM，可以轻松切换于不同的版本之间 1 NVM_HOME=C:\Develop\nvm NVM_SYMLINK=C:\Develop\nodejs NPM_HOME=C:\Develop\nvm\npm PATH=%NVM_HOME%;%NVM_SYMLINK%;%NPM_HOME% 1.2.3.环境变量 环境变量就是操作系统提供的系统级别用于存储变量的地方 系统变量和用户变量 系统变量指的是所用当前系统用户共享的变量 自己的电脑一般只有一个用户 建议将自己配置的环境变量放在用户变量中，用户变量比较干净 环境变量的变量名是不区分大小写的 变量间运行相互引用 特殊值： PATH变量（不区分大小写） PATH 相当于一个路径的引用 只要添加到PATH变量中的路径，都可以在任何目录下搜索 命令行 可以用来执行当前目录下的文件 命令 cd :change directory Node.js是一个轻内核（本身没有什么功能）的东东，所有的功能都要功能包提供 node官方提供了一些最基础的包 1.3.Node用途REPL环境（控制台环境）1.3.1.开发Web应用程序 做动态网站 开发提供数据的服务端API 1.3.2.前端开发工具基础 Node.js给前端乃至整个开发行业带来一场工业革命 刀跟火种 1.4.Node开发Web应用Demo1.4.1.复习请求与响应客户端发送到服务端的东西称之为请求报文服务端返回给客户端的东西称之为响应报文 1.5.NPM1.5.1.什么是NPMhttps://www.npmjs.com/ Node Package Manager Node应用程序依赖包的管理工具 安装卸载更新之类的操作 1.5.2.为什么使用NPM 包很多 场景：我需要用一个A，A依赖B，B依赖C 常见的包管理工具都有循环依赖的功能 你只需记住你要什么东西 1.5.3.常见的NPM操作// 安装一个包，默认安装最新稳定版本npm install package_name// –save// 初始化操作，给项目添加一个配置文件npm init// –yes参数走默认配置 如果官方数据源太慢使用 https://npm.taobao.org/ 2.Bower2.1.什么是Bower 官网 web应用程序依赖项管理工具 2.2.为什么使用Bower 方便便捷的方式管理包，zhuangbi 2.3.Bower实践 npm install -g bower // -g:global 修改npm全局路径，就是在用户目录下添加.npmrc文件 3.Sass/LESS 4.Gulp4.1.Gulp简介 链接： 官网 中文网 就是用来机械化的完成重复性质的工作 gulp的机制就是将重复工作抽象成一个个的任务， 4.2.Gulp准备工作 安装Node.js 安装 gulp 命令行工具 npm install -g gulp 初始化 gulp 项目 创建任务 - gulpfile.js 4.3.基本使用4.4.常用插件 编译 Less：gulp-less 创建本地服务器：gulp-connect 合并文件：gulp-concat 最小化 js 文件：gulp-uglify 重命名文件：gulp-rename 最小化 css 文件：gulp-minify-css 压缩html文件 gulp-minify-html 最小化图像：gulp-imagemin 5.Git5.1.什么是GIT，什么是GITHUB GIT GITHUB 5.2.环境安装5.3.GIT常用命令 6.Markdownhttps://guides.github.com/features/mastering-markdown/https://help.github.com/articles/github-flavored-markdown/https://help.github.com/articles/markdown-basics/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2Fblog%2F2016%2F10%2F24%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
