<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vue 01]]></title>
    <url>%2Fblog%2F2017%2F10%2F16%2FZYSvue01%2F</url>
    <content type="text"><![CDATA[vue: 读音: v-u-eview vue到底是什么? 一个mvvm框架(库)、和angular类似 比较容易上手、小巧 mvc: mvp mvvm mv* mvx 官网:http://cn.vuejs.org/手册： http://cn.vuejs.org/api/ vue和angular区别? vue――简单、易学 指令以 v-xxx 一片html代码配合上json，在new出来vue实例 个人维护项目 适合: 移动端项目,小巧 vue的发展势头很猛，github上start数量已经超越angular angular――上手难 指令以 ng-xxx 所有属性和方法都挂到$scope身上 angular由google维护 合适: pc端项目 共同点: 不兼容低版本IEvue基本雏形: angular展示一条基本数据:12345var app=angular.module('app',[]);app.controller('xxx',function($scope)&#123; //C $scope.msg='welcome'&#125;) html:12div ng-controller="xxx" &#123;&#123;msg&#125;&#125; vue: html:123&lt;div id="box"&gt; &#123;&#123;msg&#125;&#125;&lt;/div&gt; 123456var c=new Vue(&#123; el:'#box', //选择器 class tagName data:&#123; msg:'welcome vue' &#125;&#125;); 常用指令: angular: ng-model ng-controller ng-repeat ng-click ng-show $scope.show=function(){} 指令: 扩展html标签功能,属性 v-model 一般表单元素(input) 双向数据绑定 循环: v-for=&quot;name in arr&quot; {{$index}} v-for=&quot;name in json&quot; {{$index}} {{$key}} v-for=&quot;(k,v) in json&quot; 事件: v-on:click=&quot;函数&quot; v-on:click/mouseout/mouseover/dblclick/mousedown..... new Vue({ el:&apos;#box&apos;, data:{ //数据 arr:[&apos;apple&apos;,&apos;banana&apos;,&apos;orange&apos;,&apos;pear&apos;], json:{a:&apos;apple&apos;,b:&apos;banana&apos;,c:&apos;orange&apos;} }, methods:{ show:function(){ //方法 alert(1); } } }); 显示隐藏: v-show=“true/false” bootstrap+vue简易留言板(todolist): bootstrap: css框架 跟jqueryMobile一样 只需要给标签 赋予class，角色 依赖jquery 确认删除？和确认删除全部么? 事件: v-on:click/mouseover…… 简写的: @click=”” 推荐 事件对象: @click=”show($event)” 事件冒泡: 阻止冒泡: a). ev.cancelBubble=true; b). @click.stop 推荐 默认行为(默认事件): 阻止默认行为: a). ev.preventDefault(); b). @contextmenu.prevent 推荐 键盘: @keydown $event ev.keyCode @keyup 常用键: 回车 a). @keyup.13 b). @keyup.enter 上、下、左、右 @keyup/keydown.left @keyup/keydown.right @keyup/keydown.up @keyup/keydown.down..... 属性: v-bind:src=”” width/height/title…. 简写: :src=”” 推荐 效果能出来，但是会报一个404错误 效果可以出来，不会发404请求 class和style: :class=”” v-bind:class=”” :style=”” v-bind:style=”” :class=”[red]” red是数据 :class=”[red,b,c,d]” :class=”{red:a, blue:false}” :class=”json” data:{ json:{red:a, blue:false} }style: :style=”[c]” :style=”[c,d]” 注意: 复合样式，采用驼峰命名法 :style=”json” 模板:12345 &#123;&#123;msg&#125;&#125; 数据更新模板变化 &#123;&#123;*msg&#125;&#125; 数据只绑定一次 &#123;&#123;&#123;msg&#125;&#125;&#125; HTML转意输出----------------------------------------- 过滤器:-&gt; 过滤模板数据 系统提供一些过滤器:12345678910111213- &#123;&#123;msg| filterA&#125;&#125;- &#123;&#123;msg| filterA | filterB&#125;&#125;- uppercase eg: &#123;&#123;'welcome'| uppercase&#125;&#125;- lowercase- capitalize- currency 钱- &#123;&#123;msg| filterA 参数&#125;&#125; ....----------------------------------------- 交互: $http （ajax） 如果vue想做交互 引入: vue-resouce get: 获取一个普通文本数据: 12345this.$http.get('aa.txt').then(function(res)&#123; alert(res.data);&#125;,function(res)&#123; alert(res.status);&#125;); 给服务发送数据:√ 12345678this.$http.get('get.php',&#123; a:1, b:2&#125;).then(function(res)&#123; alert(res.data);&#125;,function(res)&#123; alert(res.status);&#125;); post:12345678910this.$http.post('post.php',&#123; a:1, b:20&#125;,&#123; emulateJSON:true&#125;).then(function(res)&#123; alert(res.data);&#125;,function(res)&#123; alert(res.status);&#125;); jsonp:https://sug.so.360.cn/suggest?callback=suggest_so&amp;word=a https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=a&amp;cb=jshow this.$http.jsonp('https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su',{ wd:'a' },{ jsonp:'cb' //callback名字，默认名字就是"callback" }).then(function(res){ alert(res.data.s); },function(res){ alert(res.status); }); https://www.baidu.com/s?wd=s 作业: 简易留言-&gt; 确认删除? 确认删除全部 用vue get 写个例子 weibo]]></content>
  </entry>
  <entry>
    <title><![CDATA[力软框架]]></title>
    <url>%2Fblog%2F2017%2F09%2F01%2F20170901rj%2F</url>
    <content type="text"><![CDATA[涉及第三方插件组件清单后端 ASP.NET MVC4EntityFramework ORMDapper ORMNPOI Excel 操作log4net 系统日志Newtonsoft.Json Json处理signalR Websocketunity 依赖注入容器 前端JS框架：Jquery-1.10.2.min、jquery-uiCSS框架：Bootstrap数据表格:JqGrid分页插件： pagination上传文件：Uploadify布局：Layout客户端验证：JQuery Validation图表：Highcharts、echarts字体图片：Font Awesome富文本：ckeditor日期控件： My97DatePicker树结构控件：jQuery WTree对话框：layer代码编辑器：syntaxhighlighter日程插件：fullcalendar工作流流程图：flow.js工作流表单富文本： simditor 手机端WebApi接口：nancyJs框架：ionic angularjs mui 开发及部署环境开发环境 vs2012及以上。sqlserver2005\oracle11g\mysql4.5及以上版本。 服务器端操作系统：Microsoft Windows Server 2008R2 及以上其它软件：IIS 7.0、.netframwork4.5]]></content>
  </entry>
  <entry>
    <title><![CDATA[想把与程序工作相关的文章放在博客园中]]></title>
    <url>%2Fblog%2F2017%2F09%2F01%2F20170901%2F</url>
    <content type="text"><![CDATA[http://www.cnblogs.com/wolf-sun/http://www.cnblogs.com/wolf-sun/p/6878868.htmlhttps://github.com/allpro/layout 初步的想法，看看能否坚持下去吧一般情况下，利用在家的时间。]]></content>
  </entry>
  <entry>
    <title><![CDATA[mysql learning (汇智网 mysql课程)]]></title>
    <url>%2Fblog%2F2017%2F04%2F28%2Fmysqllearning%2F</url>
    <content type="text"><![CDATA[初识MySQL1. 认识MySQL简介 MySQL 是一个真正的多用户、多线程SQL 数据库服务器。SQL （结构化查询语言） 是世界上最流行的和标准化的数据库语言。 MySQL 是以一个客户机/服务器结构的实现，它由一个服务器守护程序mysqld 和很多不同的客户程序和库组成。MySQL在windows上不区分大小写，Linux上表名区分大小写 MySQL主要目标是快速、健壮和易用 MySQL 具有运行速度很快、容易使用、支持查询语言、多个用户可同时连接客户机和服务器、可以运行在各种版本的UNIX以及非UNIX的系统上等优点。 编者认为 如果你在寻找一种免费的或者不昂贵的，性能优越，速度很好的数据库管理系统，那么MySQL将是首选！ 创建数据库 我们先创建一个属于自己的数据库，如下： create database test; 至于这句话表示什么意思，又有什么固定的语法，我们后面介绍。 创建数据库表 创建了数据库，接下来我们创建一个表，我们的数据操作都是针对表来的，例如： 1234create table test01_01(name nvarchar(40),age int(5)); 先输入’use test01;‘选用test01数据库，然后创建一个名为m_table的数据表，字段分别为name(varchar(50))，age(int(11))，address(varchar(50)) 添加数据 既然已经了解了MySQL的基本信息，那么我们赶紧来上手练练吧 我们先做一些简单的实例，体验一下MySQL，我们先添加一条数据到数据库表中， 至于添加数据的语法，我们后面会讲到，不要着急。先看例子，写代码锻炼一下。 12insert into m_table values(&apos;wangwu&apos;,&apos;21&apos;,&apos;北京&apos;); 请根据上面的代码添加一条名字为”zhangsan”,年龄为20，地址为”beijing”的数据到m_table表中 查询数据 上一节我们添加了一条数据，那么接下来就要查看这条数据了 这里我们只做最简单的查询数据，以后会深入讲解各种查询语句，今天我们讲的只是基础 好了，让我们看下面的这个例子 12select * from m_table; 请根据上面的代码查询出m_table表中的数据 修改数据 现在我们可以添加和查询数据了，那么接下来我们要修改数据了 修改我们上次添加的那条数据，这里的修改只是修改数据的内容 看下面的这个例子 12update m_table set name= &apos;zhangsan&apos;,age=10 where name=&apos;wangwu&apos;; 请根据上面的代码修改名字为”zhangsan”的年龄为30，地址修改为”shanghai”,并查看结果 删除数据 现在为止，我们进行了表中数据的添加，查询，修改操作，那么接下来，我们不需要这条数据了，就可以删除这条数据了。 删除数据也很简单，我们来对之前的数据进行删除吧 观察下面的实例，动手写代码，自己体验一下吧 12delete from m_table where name= &apos;zhangsan&apos;; 2. 创建数据库创建数据库 创建一个属于自己的数据库，看下面的语法 12create database [if not exists] db_name; 前面一部分是固定关键字，db_name是你要创建的数据库的名字，例如： 12create database test04; 这样我们就创建了属于自己的数据库，如果数据库已经存在，使用if not exists可以避免创建已经存在的数据库的错误，很简单吧。 显示数据库 假如你不知道服务器主机上有多少数据库存在，可以用show databases语法来显示服务器主机上的数据库，从而找到你想要的那个数据库。 我们看下它的语法 12show databases [like wild]; 显示全部数据库 12show databases; 但是有时候你知道数据库名字部分名称，这个时候我们可以用like关键字来显示，例如： 12show databases like &apos;te%&apos;; 上述实例我们只记得te开头的数据库，如果关键字在中间呢，我们使用’%st%’形式来查找； 如果关键字在最后，我们使用’%st01’来查找。 选用数据库 当前服务器有很多数据库，我们怎样才能使用我们需要的那个呢。看下面 12use db_name; use是固定关键字,db_name是你要使用的那个数据库的名称，这样我们就把db_name这个数据库变成正在使用的数据库了。也就是说，当你使用上述命令选用数据库之后，之后的任何数据库操作，都是针对你选用的数据库的。例如： 12use test04; 删除数据库 我们已经学会创建，查看和选用数据库，那么如果我们不需要这个数据库了，该怎么办呢，置之不理是不好的，数据库是会占据空间的。所以当我们完全不用的时候，最好删除掉。 我们看下删除数据库的语法 12drop database [if exists] db_name; 此命令会删除当前数据库和当前数据库中的所有数据表，所以务必确认该数据库是否完全不用！在MySQL 3.22或以后版本中，你可以使用关键词 if exists 阻止一个错误的发生， 如果数据库不存在，例如： 12drop database if exists test04; 如果数据库存在则删除，不存在也不会报错。 3. 创建表create创建数据库表 创建数据库表太常用了，只要用到数据库，我们就会用到创建数据库表，我们用create 语句来创建，看下面语法: 123create table tbl_name(create_definition,...) [type =table_type] create_definition:col_name type [not null | null][default default_value] [auto_increment][primary_key] create table是固定的关键字，后面紧跟要创建的表的名称，括号里面是字段的内容，内容可选有：是否为空，是否有默认值，是否为主键，是否自增长等等，例如： 1234create table test01_02(id varchar(50) not null auto_increment primary key,name nvarchar(40) null default &quot;002&quot;,age int(5)null default 444); 先选用test01数据库，然后创建一个名为test01_01的数据表，字段分别name(varchar)，age(int)，address(varchar) select创建数据库表 创建数据库表有多种方式，上面讲了一种，我们再看另外一种常用的，用select 语句来创建，看下面语法: 12create table tb_new_name select * from tb_old_name; 上述语句表示，从后者的表中复制一份，添加到新的数据库表中，前面是新的数据库表，之前是不存在的。例如： 12create table test01_03 select * from test01_01; 请选用test01数据库，创建一个名为test01_02的数据表，从test01_01中复制 显示数据库表信息 有时候我们需要查看某个数据库表的相关信息，比如结构，列名等等；那么我们就需要用到show/describe 语句来查看，看下面语法: 123456show tables [from db_name] [like wild] show columns from tbl_name [from db_name] [like wild] show index from tbl_name [from db_name] show table status [from db_name] [like wild] &#123;describe| desc&#125; tbl_name &#123;col_name | wild&#125; 第一种语法表示：查看某个数据库下的所有数据库表，或者根据like模糊查看某个数据库表；例如 123show tables from test01;show tables from test01 like &quot;%a%&quot;; 第二种语法表示：查看某个数据库表中的列属性,like后面跟的是列的名称的某个关键字；例如 123show columns from test01_01;show columns from test01_01 from test01 like &quot;%n%&quot;; 第三种语法表示：查看某个数据库表中的索引；例如 12show index from test01_01 from test01; 第四种语法表示：查看数据库中全部表或者某个表的状态信息，信息提供的更多；例如 123show table status from test01;show table status from test01 like &quot;%t%&quot;; 第五种语法表示：查看数据库表的信息，是show的另外一种方式；例如 123desc test01_01;describe test01_01 &quot;%n%&quot;; 请选用test01数据库，查看数据库test01下的所有数据表，并查看test01_01数据表的列属性 alter修改表结构 有时你可能需要改变一下现有表的结构，那么alter table语句将是你的合适选择。 增加列 12alter table tbl_name add col_name type 例如增加一个weight列: 12alter table test01_01 add weight int; 修改列 12alter table test01_01 modify weight varchar(50); 删除列 12alter table test01_01 drop weight; 另外一种常用方式，例如: 给列更名 12alter table test01_01 change weight wei int; 给表更名 12alter table test01_01 rename test01_04; 请选用test01数据库，为名为test01_01的数据表添加名为“sex”的列，类型varchar，查看结果，并且删除此列 4. 增加数据5. 查询数据6. 修改数据7. 删除数据数据库操作数据表操作插入数据查询数据修改&amp;删除数据]]></content>
  </entry>
  <entry>
    <title><![CDATA[Angular2 learning (汇智网 Angular2 入门课程)]]></title>
    <url>%2Fblog%2F2017%2F04%2F25%2Fangular2learning%2F</url>
    <content type="text"><![CDATA[快速上手Why Angular2 Angular1.x显然非常成功，那么，为什么要剧烈地转向Angular2？ 性能的限制 AngularJS当初是提供给设计人员用来快速构建HTML表单的一个内部工具。随着时间的推移，各种特性 被加入进去以适应不同场景下的应用开发。然而由于最初的架构限制（比如绑定和模板机制），性能的 提升已经非常困难了。 快速变化的WEB 在语言方面，ECMAScript6的标准已经完成，这意味着浏览器将很快支持例如模块、类、lambda表达式、 generator等新的特性，而这些特性将显著地改变JavaScript的开发体验。 在开发模式方面，Web组件也将很快实现。然而现有的框架，包括Angular1.x对WEB组件的支持都不够好。 移动化 想想5年前……现在的计算模式已经发生了显著地变化，到处都是手机和平板。Angular1.x没有针对移动 应用特别优化，并且缺少一些关键的特性，比如：缓存预编译的视图、触控支持等。 简单易用 说实话，Angular1.x太复杂了，学习曲线太陡峭了，这让人望而生畏。Angular团队希望在Angular2中将复杂性 封装地更好一些，让暴露出来的概念和开发接口更简单。 Rob Eisenberg / Angular 2.0 Team ES6工具链 要让Angular2应用跑起来不是件轻松的事，因为它用了太多还不被当前主流浏览器支持 的技术。所以，我们需要一个工具链： 12345 Your Web App Angular2 systemjs ES6浏览器traceur es6-module-loader ES5浏览器 Angular2是面向未来的科技，要求浏览器支持ES6+，我们现在要尝试的话，需要加一些 垫片来抹平当前浏览器与ES6的差异： systemjs - 通用模块加载器，支持AMD、CommonJS、ES6等各种格式的JS模块加载es6-module-loader - ES6模块加载器，systemjs会自动加载这个模块traceur - ES6转码器，将ES6代码转换为当前浏览器支持的ES5代码。systemjs会自动加载 这个模块。 初识Angular2 写一个Angular2的Hello World应用相当简单，分三步走： 1. 引入Angular2预定义类型12import &#123;Component,View,bootstrap&#125; from "angular2/angular2"; 2. 实现一个Angular2组件 实现一个Angular2组件也很简单，定义一个类，然后给这个类添加注解： 1234@Component(&#123;selector:"ez-app"&#125;)@View(&#123;template:"&lt;h1&gt;Hello,Angular2&lt;/h1&gt;"&#125;)class EzApp&#123;&#125; class也是ES6的关键字，用来定义一个类。@Component和@View都是给类EzApp附加的元信息， 被称为注解/Annotation。 @Component最重要的作用是通过selector属性（值为CSS选择符），指定这个组件渲染到哪个DOM对象上。 @View最重要的作用是通过template属性，指定渲染的模板。 3. 渲染组件到DOM 将组件渲染到DOM上，需要使用自举/bootstrap函数： 12bootstrap(EzApp); 这个函数的作用就是通知Angular2框架将EzApp组件渲染到DOM树上。 简单吗？我知道你一定还有疑问，别着急，我们慢慢把缺失的知识点补上！ 注解/Annotation 你一定好奇@Component和@View到底是怎么回事。看起来像其他语言（比如python） 的装饰器，是这样吗？ ES6规范里没有装饰器。这其实利用了traceur的一个实验特性：注解。给一个类 加注解，等同于设置这个类的annotations属性： 1234//注解写法@Component(&#123;selector:"ez-app"&#125;)class EzApp&#123;...&#125; 等同于 123class EzApp&#123;...&#125;EzApp.annotations = [new Component(&#123;selector:"ez-app"&#125;)]; 很显然，注解可以看做编译器（traceur）层面的语法糖，但和python的装饰器不同， 注解在编译时仅仅被放在annotation里，编译器并不进行解释展开 - 这个解释的工作是 Angular2完成的： 据称，注解的功能就是Angular2团队向traceur团队提出的，这不是traceur的默认选项， 因此你看到，我们配置systemjs在使用traceur模块时打开注解： 12345System.config(&#123; map:&#123;traceur:"lib/traceur"&#125;, traceurOptions: &#123;annotations: true&#125;&#125;); 1234567891011121314151617181920212223242526272829303132333435363738&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;hello,angular2&lt;/title&gt; &lt;!--模块加载器--&gt; &lt;script type="text/javascript" src="lib/system@0.16.11.js"&gt;&lt;/script&gt; &lt;!--Angular2模块库--&gt; &lt;script type="text/javascript" src="lib/angular2.dev.js"&gt;&lt;/script&gt; &lt;script&gt; //设置模块加载规则 System.baseURL = document.baseURI; System.config(&#123; map:&#123;traceur:"lib/traceur"&#125;, traceurOptions: &#123;annotations: true&#125; &#125;); &lt;/script&gt; &lt;/head&gt;&lt;body&gt; &lt;!--组件渲染锚点--&gt; &lt;my-app&gt;&lt;/my-app&gt; &lt;!--定义一个ES6脚本元素--&gt; &lt;script type="module"&gt; //从模块库引入三个类型定义 import &#123;Component,View,bootstrap&#125; from "angular2/angular2"; //组件定义 @Component(&#123;selector:"my-app"&#125;) @View(&#123;template:"&lt;h1&gt;Hello,Annotation&lt;/h1&gt;"&#125;) class EzApp&#123;&#125; //渲染组件 bootstrap(EzApp); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12h1&#123;background:black;color:white;display:inline-block&#125; 小结 如果你了解一点Angular1.x的bootstrap，可能隐约会感受到Angular2中bootstrap的一些 变化 - 我指的并非代码形式上的变化。 以组件为核心 在Angular1.x中，bootstrap是围绕DOM元素展开的，无论你使用ng-app还是手动执行bootstrap() 函数，自举过程是建立在DOM之上的。 而在Angular2中，bootstrap是围绕组件开始的，你定义一个组件，然后启动它。如果没有一个组件， 你甚至都没有办法使用Angular2！ 支持多种渲染引擎 以组件而非DOM为核心，意味着Angular2在内核隔离了对DOM的依赖 - DOM仅仅作为一种可选的渲染引擎存在： 123 Angular2 Core Render APIDOM Render Server Render Android Render ios Render 上面的图中，DOM Render已经实现，Server Render正在测试，iOS Render和Android Render 是可预料的特性，虽然我们看不到时间表。 这有点像React了。 组件开发 - 模板语法1. 最简单的模板 组件的View注解用来声明组件的外观，它最重要的属性就是template - 模板。 Angular2的模板是兼容HTML语法的，这意味着你可以使用任何标准的HTML标签编写 组件模板。 所以，在最简单的情况下，一个Angular2组件的模板由标准的HTML元素构成，看起来就是 一段HTML码流。Angular2将原封不同地渲染这段模板： 有两种方法为组件指定渲染模板： 1. 内联模板 可以使用组件的View注解中的template属性直接指定内联模板： 12345@View(&#123; template : `&lt;h1&gt;hello&lt;/h1&gt; &lt;div&gt;...&lt;/div&gt;`&#125;) 在ES6中，使用一对`符号就可以定义多行字符串，这使得编写内联的模板轻松多了。 2. 外部模板 也可以将模板写入一个单独的文件： 1234&lt;!--ezcomp-tpl.html--&gt;&lt;h1&gt;hello&lt;/h1&gt;&lt;div&gt;...&lt;/div&gt; 然后在定义组件时，使用templateUrl引用外部模板： 1234@View(&#123; templateUrl : "ezcomp-tpl.html"&#125;) 2. directives - 使用组件 在Angular2中，一个组件的模板内除了可以使用标准的HTML元素，也可以使用自定义的组件！ 这是相当重要的特性，意味着Angular2将无偏差地对待标准的HTML元素和你自己定义的组件。这样， 你可以建立自己的领域建模语言了，这使得渲染模板和视图模型的对齐更加容易，也使得模板的语义性 更强： 声明要在模板中使用的组件 不过，在使用自定义组件之前，必需在组件的ViewAnnotation中通过directives属性声明这个组件： 12345@View(&#123; directives : [EzComp], template : "&lt;ez-comp&gt;&lt;/ez-comp&gt;"&#125;) 你应该注意到了，directives属性的值是一个数组，这意味着，你需要在这里声明所有你需要在模板 中使用的自定义组件。 练习：修改示例代码： 增加一个EzLogo组件 在EzCard组件的模板中使用这个组件 3. - 文本插值 在模板中使用可以的方式绑定组件模型中的表达式，当表达式变化时， Angular2将自动更新对应的DOM对象： 上图的示例中，模板声明了h1的内容将绑定到组件实例的title变量。Angular2 框架将实时检测title的变化，并在其变化时自动更新DOM树中h1的内容。 练习 修改模板，将“新闻来源”字段及内容移动到文章尾部。 4. [property] - 绑定属性 在模板中，也可以使用一对中括号将HTML元素或组件的属性绑定到组件模型的某个表达式， 当表达式的值变化时，对应的DOM对象将自动得到更新： 等价的，你也可以使用bind-前缀进行属性绑定： 12@View(&#123;template:`&lt;h1 bind-text-content="title"&gt;&lt;/h1&gt;`&#125;) 很容易理解，通过属性，应用相关的数据流入组件，并影响组件的外观与行为。 需要注意的是，属性的值总是被当做调用者模型中的表达式进行绑定，当表达式变化时，被 调用的组件自动得到更新。如果希望将属性绑定到一个常量字符串，别忘了给字符串加引号，或者， 去掉中括号： 1234567//错误，Angular2将找不到表达式 Hello,Angular2@View(&#123;template:`&lt;h1 [text-content]="Hello,Angular2"&gt;&lt;/h1&gt;`&#125;)//正确，Angular2识别出常量字符串表达式 'Hello,Angular2'@View(&#123;template:`&lt;h1 [text-content]="'Hello,Angular2'"&gt;&lt;/h1&gt;`&#125;)//正确，Angular2识别出常量字符串作为属性textContent的值@View(&#123;template:`&lt;h1 text-content="Hello,Angular2"&gt;&lt;/h1&gt;`&#125;) 练习 修改示例代码，使EzApp组件的标题颜色每秒钟随机变化一次！ 5. (event) - 监听事件 在模板中为元素添加事件监听很简单，使用一对小括号包裹事件名称，并绑定 到表达式即可： 上面的代码实例为DOM对象h1的click事件添加监听函数onClick()。 另一种等效的书写方法是在事件名称前加on-前缀： 12@View(&#123;template : `&lt;h1 on-click="onClick()"&gt;HELLO&lt;/h1&gt;`&#125;) 练习 修改示例代码，点击EzApp组件的h1标题时，自动变换名称！ 6. #var - 局部变量 有时模板中的不同元素间可能需要互相调用，Angular2提供一种简单的语法将元素 映射为局部变量：添加一个以#或var-开始的属性，后续的部分表示变量名， 这个变量对应元素的实例。 在下面的代码示例中，我们为元素h1定义了一个局部变量v_h1，这个变量指向 该元素对应的DOM对象，你可以在模板中的其他地方调用其方法和属性： 1234567@View(&#123; template : ` &lt;h1 #v_h1&gt;hello&lt;/h1&gt; &lt;button (click) = "#v_h1.textContent = 'HELLO'"&gt;test&lt;/button&gt; `&#125;) 如果在一个组件元素上定义局部变量，那么其对应的对象为组件的实例： 12345@View(&#123; directives:[EzCalc], template : "&lt;ez-calc #c&gt;&lt;/ez-calc&gt;"&#125;) 在上面的示例中，模板内的局部变量c指向EzCalc的实例。 练习 为示例代码的变色按钮添加事件监听，点击该按钮时，将EzApp组件的h1标题 变为黑色背景，白色字体！ 组件开发 - 模板的逻辑控制NgIf- 条件逻辑使用条件逻辑 有时我们需要模板的一部分内容在满足一定条件时才显示，比如右边示例中的EzReader组件， 对于试用用户，它将在正文之上额外显示一个广告： 这是指令NgIf发挥作用的场景，它评估属性ngIf的值是否为真，来决定是否渲染 template元素的内容： 123456789@View(&#123; template : `&lt;!--根据变量trial的值决定是否显示广告图片--&gt; &lt;template [ng-if]="trial==true"&gt; &lt;img src="ad.jpg"&gt; &lt;/template&gt; &lt;!--以下是正文--&gt; &lt;pre&gt;...&lt;/pre&gt; &#125;) Angular2同时提供了两种语法糖，让NgIf写起来更简单，下面的两种书写方法和上面 的正式语法是等效的： NgSwitch - 分支逻辑 如果组件的模板需要根据某个表达式的不同取值展示不同的片段，可以使用NgSwitch系列指令 来动态切分模板。比如右边示例中的广告组件EzPromotion，需要根据来访者性别的不同推送 不同的广告： NgSwitch包含一组指令，用来构造包含多分支的模板： NgSwitch NgSwitch指令可以应用在任何HTML元素上，它评估元素的ngSwitch属性值，并根据这个值 决定应用哪些template的内容（可以同时显示多个分支）： 12&lt;ANY [ng-switch]="expression"&gt;...&lt;/ANY&gt; NgSwitchWhen NgSwitchWhen指令必须应用在NgSwitch指令的子template元素上，它通过属性ngSwitchWhen指定一个表达式， 如果该表达式与父节点的NgSwitch指令指定的表达式值一致，那么显示这个template的内容： 1234567&lt;ANY [ng-switch]="..."&gt; &lt;!--与变量比较--&gt; &lt;template [ng-switch-when]="variable"&gt;...&lt;/template&gt; &lt;!--与常量比较--&gt; &lt;template ng-switch-when="constant"&gt;...&lt;/template&gt;&lt;/ANY&gt; NgFor - 循环逻辑组件开发 - 为模板应用样式组件开发 - 属性与事件组件开发 - 表单输入组件开发 - 调用服务组件路由 - 原理与应用]]></content>
  </entry>
  <entry>
    <title><![CDATA[Sass learning (汇智网 sass课程)]]></title>
    <url>%2Fblog%2F2017%2F04%2F24%2Fsasslearning%2F</url>
    <content type="text"><![CDATA[Sass简介什么是css预处理器 众所周知css并不能算是一们真正意义上的“编程”语言，它本身无法未完成像其它编程语言一样的嵌套、继承、设置变量等工作。 在程序员眼里，CSS是一件很麻烦的东西。它没有变量，也没有条件语句，只是一行行单纯的描述，写起来相当费事。 CSS这样写 为了解决css的不足，开发者们想到了编写一种对css进行预处理的“中间语言”，可以实现一些“编程”语言才有的功能，然后自动编译成css供浏览识别，这样既一定程度上弥补了css的不足，也无需一种新的语言来代替css以供浏览器识别。于是css预处理语言SASS就应运而生了。 什么是Sass Sass 是一门高于 CSS 的元语言，它能用来清晰地、结构化地描述文件样式，有着比普通 CSS 更加强大的功能。 Sass 能够提供更简洁、更优雅的语法，同时提供多种功能来创建可维护和管理的样式表。 Sass 是最早的css预处理语言，有比less更为强大的功能。但因其一开始的缩进式语法并不能被开发者们接受，所以使用率不高，不过由于其强大的功能和Ruby on Rails 的大力推动，逐渐被更多开发者使用。 Sass 是采用的Ruby语言编写的一款css预处理语言，它诞生于2007年，是最早成熟css预处理语言。最初它是为了配合haml而设计的，因此有着和haml一样的缩进式风格。 Sass从第三代开始，放弃了缩进式风格，并且完全向下兼容普通的css代码，这一代的Sass也被称为Scss。 Sass 和 SCSS 有什么区别？ Sass 和 SCSS 其实是同一种东西，我们平时都称之为 Sass，两者之间不同之处有以下两点： 文件扩展名不同，Sass 是以“.sass”后缀为扩展名，而 SCSS 是以“.scss”后缀为扩展名 语法书写方式不同，Sass 是以严格的缩进式语法规则来书写，不带大括号({})和分号(;)，而 SCSS 的语法书写和我们的 CSS 语法书写方式非常类似。 先来看一个示例：Sass 语法123456$font-stack: Helvetica, sans-serif //定义变量$primary-color: #fff //定义变量body font: 100% $font-stack color: $primary-color SCSS 语法1234567$font-stack: Helvetica, sans-serif;$primary-color: #fff;body &#123; font: 100% $font-stack; color: $primary-color;&#125; 编译出来的 CSS1234body &#123; font: 100% Helvetica, sans-serif; color: #fff;&#125; 文件后缀名 sass有两种后缀名文件： 一种后缀名为sass，不使用大括号和分号； 另一种就是我们这里使用的scss文件，这种和我们平时写的css文件格式差不多，使用大括号和分号。 而本教程中所说的所有sass文件都指后缀名为scss的文件。在此也建议使用后缀名为scss的文件，以避免sass后缀名的严格格式要求报错。 //文件后缀名为sass的语法 1234567891011121314body background: #eee font-size:12pxp background: #0982c1//文件后缀名为scss的语法 body &#123; background: #eee; font-size:12px;&#125;p&#123; background: #0982c1;&#125; 注意：“.sass”只能使用 Sass 老语法规则（缩进规则），“.scss”使用的是 Sass 的新语法规则，也就是 SCSS 语法规则（类似 CSS 语法格式）。 特别注意：本系列教程后面采用的语法格式都将使用的是 SCSS 语法格式。 四种style生成后的css 在 Sass 中编译出来的样式风格也可以按不同的样式风格显示。其主要包括以下几种样式风格： 嵌套输出方式 nested 展开输出方式 expanded 紧凑输出方式 compact 压缩输出方式 compressed 在知识点中，嵌套输出方式，在前端是可以看到效果的，后几种方式是需要在命令行中编译的，在编译的时候分别带上参数“ –style expanded –style compact –style compressed”: Sass 提供了一种嵌套显示 CSS 文件的方式 123456789101112131415nav &#123; ul &#123; margin: 0; padding: 0; list-style: none; &#125; li &#123; display: inline-block; &#125; a &#123; display: block; padding: 6px 12px; text-decoration: none; &#125;&#125; nested 编译出来： 12345678910nav ul &#123; margin: 0; padding: 0; list-style: none; &#125;nav li &#123; display: inline-block; &#125;nav a &#123; display: block; padding: 6px 12px; text-decoration: none; &#125; expanded 这个输出的 CSS 样式风格和 nested 类似，只是大括号在另起一行，同样上面的代码，编译出来： 12345678910111213nav ul &#123; margin: 0; padding: 0; list-style: none;&#125;nav li &#123; display: inline-block;&#125;nav a &#123; display: block; padding: 6px 12px; text-decoration: none;&#125; compact 编译出来： 123nav ul &#123; margin: 0; padding: 0; list-style: none; &#125;nav li &#123; display: inline-block; &#125;nav a &#123; display: block; padding: 6px 12px; text-decoration: none; &#125; compressed 编译出来： 1nav ul&#123;margin:0;padding:0;list-style:none&#125;nav li&#123;display:inline-block&#125;nav a&#123;display:block;padding:6px 12px;text-decoration:none&#125; ##变量 声明变量 JavaScript中声明变量都是使用关键词“var”开头，但是在 Sass 不使用这个关键词，而是使用美元符号“$”开头。 变量声明 Sass 的变量包括三个部分： 声明变量的符号“$” 变量名称 赋予变量的值 //sass style $highlight-color: #F90; 请在上面的基础上定义一个 变量($color)，并给赋值为蓝色。 ###变量的引用 凡是css属性的标准值（比如说1px或者bold）可存在的地方，变量就可以使用。css生成时，变量会被它们的值所替代。之后，如果你需要一个不同的值，只需要改变这个变量的值，则所有引用此变量的地方生成的值都会随之改变。 1234$color: #F90;.box2 &#123; border: 1px solid $color;&#125; //编译后 123.box2 &#123; border: 1px solid #F90;&#125; 看上边示例中的$color变量，它被直接赋值给border属性，当这段代码被编译输出css时，$color会被#F90这一颜色值所替代。产生的效果就是给box2这个类一条1像素宽、实心且颜色值为#F90的边框。 在声明变量时，变量值也可以引用其他变量。当你通过粒度区分，为不同的值取不同名字时，这相当有用。下例在独立的颜色值粒度上定义了一个变量，且在另一个更复杂的边框值粒度上也定义了一个变量： 12345$color: #F90;$border: 1px solid $color;.box2 &#123; border: $border;&#125; //编译后 123.box2 &#123; border: 1px solid #F90;&#125; 这里，$border变量的声明中使用了$color这个变量。产生的效 果就跟你直接为border属性设置了一个1px $color solid的值是一样的。 请定义的变量$color为蓝色，在.box2中为color调用。 普通变量与默认变量普通变量 定义之后可以在全局范围内使用。1234$color: #F90;.box2 &#123; border: 1px solid $color;&#125; 默认变量 sass的默认变量仅需要在值后面加上!default即可。 1234$baseHeight: 1.6 !default;body&#123; line-height: $baseHeight; &#125; sass的默认变量一般是用来设置默认值，然后根据需求来覆盖的，只需要在默认变量之前重新声明下变量，重新赋值即可 12345$baseHeight: 2;$baseHeight: 1.6 !default;body&#123; line-height: $baseHeight; &#125; 可以看出现在编译后的line-height为2，而不是我们默认的1.6。默认变量的价值在进行组件化开发的时候会非常有用。 局部变量和全局变量 从 3.4 版本开始，Sass 已经可以正确处理作用域的概念，并通过创建一个新的局部变量来代替。 先来看一下代码例子： //SCSS 12345678910111213$color: blue !default;//定义全局变量(在选择器、函数、混合宏...的外面定义的变量为全局变量).box1 &#123; color: $color;//调用全局变量&#125;p &#123; $color: red;//定义局部变量 a &#123; color: $color;//调用局部变量 &#125;&#125;.box2 &#123; color: $color;//调用全局变量&#125; css 的结果： //CSS 123456789.box1 &#123; color: blue;&#125;p a &#123; color: red;&#125;.box2 &#123; color: blue;&#125; 上面的示例演示可以得知，在元素内部定义的变量不会影响其他元素。如此可以简单的理解成全局变量就是定义在元素外面的变量，如下代码： $color:orange !default; $color 就是一个全局变量，而定义在元素内部的变量，比如 $color:red; 是一个局部变量。 除此之外，Sass 现在还提供一个 !global 参数。!global 和 !default 对于定义变量都是很有帮助的。 现在我们来试试 !global 参数 //SCSS 12345678910111213$color: blue ;.stage &#123; color: $color;&#125;p &#123; $color: red !global; a &#123; color: $color; &#125;&#125;div &#123; color: $color;&#125; 我们把!global参数设置到局部变量上，div调用$color,也会被赋值为 red。 嵌套-选择器嵌套 所谓选择器嵌套指的是在一个选择器中嵌套另一个选择器来实现继承，从而增强了sass文件的结构性和可读性。 在选择器嵌套中，可以使用&amp;表示父元素选择器 Sass style 1234567891011121314#top_nav&#123; line-height: 40px; li&#123; float:left; &#125; a&#123; padding: 0 10px; color: #fff; &amp;:hover&#123; color:#ddd; &#125; &#125;&#125; CSS style 12345678910111213#top_nav&#123; line-height: 40px;&#125;#top_nav li&#123; float:left;&#125;#top_nav a&#123; padding: 0 10px; color: #fff;&#125;#top_nav a:hover&#123; color:#ddd;&#125; 请最终编译CSS是这样的 12#top_nav a&#123; padding: 0 10px; color: #fff; &#125; #top_nav a:hover&#123; color:#ddd; &#125; ，用sass语法练习下。 嵌套-属性嵌套 所谓属性嵌套指的是有些属性拥有同一个开始单词，如border-width，border-color都是以border开头。实例如下： Sass语法： 12345678910111213.box2 &#123; border: &#123; style: solid; left: &#123; width: 4px; color: #888; &#125; right: &#123; width: 2px; color: #ccc; &#125; &#125;&#125; 编译后的CSS 1234567.box2 &#123; border-style: solid; border-left-width: 4px; border-left-color: #888; border-right-width: 2px; border-right-color: #ccc; &#125; 请用Sass语法编译，最终编译CSS是这样的 1.wrap &#123; font-size: 14px; font-weight: bold; &#125; 混合(mixin)混合声明和调用 sass中使用@mixin声明混合，可以传递参数，参数名以$符号开始，多个参数以逗号分开，也可以给参数设置默认值。 声明的@mixin通过@include来调用。 在 Sass 中，使用“@mixin”来声明一个混合宏。如： 1234 @mixin border-radius&#123; -webkit-border-radius: 5px; border-radius: 5px;&#125; 其中 @mixin 是用来声明混合宏的关键词，有点类似 CSS 中的 @media、@font-face 一样。border-radius 是混合宏的名称。大括号里面是复用的样式代码。 在一个按钮中要调用定义好的混合宏“border-radius”，可以这样使用： 123button &#123; @include border-radius;&#125; 这个时候编译出来的 CSS: 1234button &#123; -webkit-border-radius: 5px; border-radius: 5px;&#125; 无参数mixin Sass 的混合宏有一个强大的功能，可以无参，可以传参，那么在 Sass 中我们先来学习下 在混合宏中，可以传一个不带任何值的参数，比如： 1234 @mixin center-block &#123; margin-left:auto; margin-right:auto;&#125; 在混合宏“center-block”中定义了无参数。 调用混合宏： 123.box2&#123; @include center-block;&#125; 编译出来的 CSS: 1234.box2&#123; margin-left:auto; margin-right:auto;&#125; 有参数mixin 在 Sass 的混合宏中，还可以给混合宏的参数传一个默认值，例如： 1234 @mixin opacity($opacity:50) &#123; opacity: $opacity / 100; filter: alpha(opacity=$opacity);&#125; 在混合宏“opacity”传了一个参数“$opacity”，而且给这个参数赋予了一个默认值“50”。 在调用类似这样的混合宏时，假设你的页面中的圆角很多地方都是需要的，那么这个时候只需要调用默认的混合宏“opacity”: 123.opacity&#123; @include opacity; //参数使用默认值&#125; 编译出来的 CSS: 1234.opacity&#123; opacity: 50 / 100; filter: alpha(opacity=50);&#125; 那么可以随机给混合宏传值，如： 123.opacity-80&#123; @include opacity(80); //传递参数&#125; 编译出来的 CSS: 1234.opacity-80&#123; opacity: 80 / 100; filter: alpha(opacity=80);&#125; 请用Sass语法编译，最终编译CSS是这样的 .btn { -webkit-border-radius: 3px; border-radius: 3px; }把一个按钮设置成3px圆角。 多个参数mixin 调用时可直接传入值，如@include传入参数的个数小于@mixin定义参数的个数，则按照顺序表示，后面不足的使用默认值，如不足的没有默认值则报错。 除此之外还可以选择性的传入参数，使用参数名与值同时传入。 sass style示例： 12345 @mixin horizontal-line($border:1px dashed #ccc, $padding:10px)&#123; border-bottom:$border; padding-top:$padding; padding-bottom:$padding; &#125; 在混合宏“horizontal-line”就传了多个参数。在实际调用和其调用其他混合宏是一样的： 123456.imgtext-h li&#123; @include horizontal-line(1px solid #ccc);&#125;.imgtext-h--product li&#123; @include horizontal-line($padding:15px);&#125; 最终编译的CSS 12345678910.imgtext-h li &#123; border-bottom: 1px solid #cccccc; padding-top: 10px; padding-bottom: 10px;&#125;.imgtext-h--product li &#123; border-bottom: 1px dashed #cccccc; padding-top: 15px; padding-bottom: 15px;&#125; 请用Sass语法编译，声明一个混合boxSize，有两个参数高度和宽度，在.box中调用此混合并为赋值宽度100px，高度200px。编译生成的css为 .box { width: 100px; height: 200px; } 多组值参数mixin 如果一个参数可以有多组值，如box-shadow、transition等，那么参数则需要在变量后加三个点”…”表示，如$variables…。 box-shadow可以有多组值，所以在变量参数后面添加… 1234 @mixin box-shadow($shadow...) &#123; -webkit-box-shadow:$shadow; box-shadow:$shadow;&#125; 在实际调用中： 1234.box&#123; border:1px solid #ccc; @include box-shadow(0 2px 2px rgba(0,0,0,.3),0 3px 3px rgba(0,0,0,.3),0 4px 4px rgba(0,0,0,.3));&#125; 编译出来的CSS: 12345.box&#123; border:1px solid #ccc; -webkit-box-shadow:0 2px 2px rgba(0,0,0,.3),0 3px 3px rgba(0,0,0,.3),0 4px 4px rgba(0,0,0,.3); box-shadow:0 2px 2px rgba(0,0,0,.3),0 3px 3px rgba(0,0,0,.3),0 4px 4px rgba(0,0,0,.3);&#125; ##继承 使用选择器继承来精简CSS 使用sass的时候，最后一个减少重复的主要特性就是选择器继承。基于Nicole Sullivan面向对象的css的理念，选择器继承是说一个选择器可以继承为另一个选择器定义的所有样式。这个通过@extend语法实现，如下代码: //通过选择器继承继承样式 12345678.error &#123; border: 1px red; background-color: #fdd;&#125;.seriousError &#123; @extend .error; border-width: 3px;&#125; 在上边的代码中，.seriousError将会继承样式表中任何位置处为.error定义的所有样式。以class=”seriousError” 修饰的html元素最终的展示效果就好像是class=”seriousError error”。相关元素不仅会拥有一个3px宽的边框，而且这个边框将变成红色的，这个元素同时还会有一个浅红色的背景，因为这些都是在.error里边定义的样式。 被编译为: 123456.error, .seriousError &#123;border: 1px red;background-color: #fdd; &#125; .seriousError &#123;border-width: 3px; &#125; 使用继承应用场景 混合器主要用于展示性样式的重用，而类名用于语义化样式的重用。因为继承是基于类的（有时是基于其他类型的选择器），所以继承应该是建立在语义化的关系上。当一个元素拥有的类（比如说.seriousError）表明它属于另一个类（比如说.error），这时使用继承再合适不过了。 这有点抽象，所以我们从几个方面来阐释一下。想象一下你正在编写一个页面，给html元素添加类名，你发现你的某个类（比如说.seriousError）另一个类（比如说.error）的细化。你会怎么做？ 你可以为这两个类分别写相同的样式，但是如果有大量的重复怎么办？使用sass时，我们提倡的就是不要做重复的工作。 你可以使用一个选择器组（比如说.error 、.seriousError）给这两个选择器写相同的样式。如果.error的所有样式都在同一个地方，这种做法很好，但是如果是分散在样式表的不同地方呢？再这样做就困难多了。 你可以使用一个混合器为这两个类提供相同的样式，但当.error的样式修饰遍布样式表中各处时，这种做法面临着跟使用选择器组一样的问题。这两个类也不是恰好有相同的 样式。你应该更清晰地表达这种关系。 综上所述你应该使用@extend。让.seriousError从.error继承样式，使两者之间的关系非常清晰。更重要的是无论你在样式表的哪里使用.error .seriousError都会继承其中的样式。 继承的高级用法 任何css规则都可以继承其他规则，几乎任何css规则也都可以被继承。大多数情况你可能只想对类使用继承，但是有些场合你可能想做得更多。最常用的一种高级用法是继承一个html元素的样式。尽管默认的浏览器样式不会被继承，因为它们不属于样式表中的样式，但是你对html元素添加的所有样式都会被继承。 接下来的这段代码定义了一个名为disabled的类，样式修饰使它看上去像一个灰掉的超链接。通过继承a这一超链接元素来实现： 1234.disabled &#123; color: gray; @extend a;&#125; 假如一条样式规则继承了一个复杂的选择器，那么它只会继承这个复杂选择器命中的元素所应用的样式。要继承的不仅仅是一个类名，可以是一个id也可以是一个元素，也可以是某个状态，任何选择器都能继承。如下 SCSS代码 123456.hoverlink &#123; @extend a:hover;&#125;a:hover &#123; text-decoration: underline;&#125; 编译后的CSS代码 123a:hover, .hoverlink &#123; text-decoration: underline;&#125; 就像上面编译出来的一样，在hover状态下的样式也能继承。所以不仅是a的hover状态，几乎任何选择器都能继承。 继承多个选择器 在编写的过程中，往往会遇到一个选择器要继承多个选择器的样式，那么这应该怎么办呢?看看下面的小实例吧。 SCSS代码1234567891011121314.one &#123; width:100px;height:100px;&#125;.two &#123; /*继承的样式*/ @extend .one; @extend .three; /*独立的样式*/ background:red; border:5px solid #000;&#125;.three &#123; padding:10px;&#125; 编译后的CSS代码12345678910111213.one, .two &#123; width: 100px; height: 100px;&#125; .two &#123; background: red; border: 5px solid #000;&#125; .three, .two &#123; padding: 10px;&#125; 继承的注意事项 跟变量和混合器不同，继承不是仅仅用css样式替换@extend处的代码那么简单。为了不让你对生成的css感觉奇怪，对这背后的工作原理有一定了解是非常重要的。 @extend背后最基本的想法是，如果.seriousError @extend .error， 那么样式表中的任何一处.error都用.error.seriousError这一选择器组进行替换。这就意味着相关样式会如预期那样应用到.error和.seriousError。当.error出现在复杂的选择器中，比如说h1.error .error a或者#main .sidebar input.error[type=”text”]，那情况就变得复杂多了，但是不用担心，sass已经为你考虑到了这些。 关于@extend有两个要点你应该知道。 跟混合器相比，继承生成的css代码相对更少。因为继承仅仅是重复选择器，而不会重复属性，所以使用继承往往比混合器生成的css体积更小。如果你非常关心你站点的速度，请牢记这一点。继承遵从css层叠的规则。当两个不同的css规则应用到同一个html元素上时，并且这两个不同的css规则对同一属性的修饰存在不同的值，css层叠规则会决定应用哪个样式。相当直观：通常权重更高的选择器胜出，如果权重相同，定义在后边的规则胜出。 混合器本身不会引起css层叠的问题，因为混合器把样式直接放到了css规则中，而继承存在样式层叠的问题。被继承的样式会保持原有定义位置和选择器权重不变。通常来说这并不会引起什么问题，但是知道这点总没有坏处。 Sass基本特性选择器占位符%placeholder 从sass 3.2.0以后就可以定义占位选择器%。这种选择器的优势在于：如果不调用则不会有任何多余的css文件，避免了以前在一些基础的文件中预定义了很多基础的样式，然后实际应用中不管是否使用了@extend去继承相应的样式，都会解析出来所有的样式。占位选择器以%标识定义，通过@extend调用。 123456%mar &#123; margin: 5px;&#125;%pad&#123; padding: 5px;&#125; 这段代码没有被 @extend 调用，他并没有产生任何代码块，只是静静的躺在你的某个 SCSS 文件中。只有通过 @extend 调用才会产生代码： //SCSS 12345678910111213141516171819%mar &#123; margin: 5px;&#125;%pad&#123; padding: 5px;&#125; .btn &#123; @extend %mar; @extend %pad;&#125; .block &#123; @extend %mar; span &#123; @extend %pad; &#125;&#125; 编译出来的CSS //CSS1234567.btn, .block &#123; margin: 5px;&#125; .btn, .block span &#123; padding: 5px;&#125; 从编译出来的 CSS 代码可以看出，通过 @extend 调用的占位符，编译出来的代码会将相同的代码合并在一起。 数据类型 SassScript 支持六种主要的数据类型： 数字（例如 1.2、13、10px） 文本字符串，无论是否有引号（例如 “foo”、’bar’、baz） 颜色（例如 blue、#04a3f9、rgba(255, 0, 0, 0.5)） 布尔值（例如 true、false） 空值（例如 null） 值列表，用空格或逗号分隔（例如 1.5em 1em 0 2em、Helvetica, Arial, sans-serif） SassScript 还支持所有其他 CSS 属性值类型， 例如 Unicode 范围和 !important 声明。 然而，它不会对这些类型做特殊处理。 它们只会被当做不带引号的字符串看待。 字符串 CSS 提供了两种类型的字符串： 带引号的字符串，例如 “Lucida Grande” 或 ‘http://sass-lang.com&#39;； 不带引号的字符串，例如 sans-serif 或 bold。 编译 CSS 文件时不会改变其类型。只有一种情况例外，使用 #{ }插值语句 (interpolation) 时，有引号字符串将被编译为无引号字符串，这样方便了在混合指令 (mixin) 中引用选择器名。 1234567 @mixin firefox-message($selector) &#123; body.firefox #&#123;$selector&#125;:before &#123; content: "Hi, hubwiz users!"; &#125;&#125; @include firefox-message(".header"); 被编译为： 12body.firefox .header:before &#123; content: "Hi, hubwiz users!"; &#125; 注意：当 deprecated = property syntax 时，所有的字符串都将被编译为无引号字符串，不论是否使用了引号。 值列表 所谓值列表 (lists) 是指 Sass 如何处理 CSS 中： margin: 10px 15px 0 0 或者： font-face: Helvetica, Arial, sans-serif 像上面这样通过空格或者逗号分隔的一系列的值。 事实上，独立的值也被视为值列表——只包含一个值的值列表。 Sass列表函数（Sass list functions）赋予了值列表更多功能： nth函数（nth function） 可以直接访问值列表中的某一项； join函数（join function） 可以将多个值列表连结在一起； append函数（append function） 可以在值列表中添加值； @each规则（@each rule） 则能够给值列表中的每个项目添加样式。 值列表中可以再包含值列表，比如 1px 2px, 5px 6px 是包含 1px 2px 与 5px 6px 两个值列表的值列表。如果内外两层值列表使用相同的分隔方式，要用圆括号包裹内层，所以也可以写成 (1px 2px) (5px 6px)。当值列表被编译为 CSS 时，Sass 不会添加任何圆括号，因为 CSS 不允许这样做。(1px 2px) (5px 6px)与 1px 2px 5px 6px 在编译后的 CSS 文件中是一样的，但是它们在 Sass 文件中却有不同的意义，前者是包含两个值列表的值列表，而后者是包含四个值的值列表。 可以用 () 表示空的列表，这样不可以直接编译成 CSS，比如编译 font-family: ()时，Sass 将会报错。如果值列表中包含空的值列表或空值，编译时将清除空值，比如 1px 2px () 3px 或 1px 2px null 3px。 运算数字运算 所有数据类型都支持等式运算 (== and !=)。 另外，每种数据类型也有其支持的特殊运算符。 SassScript 支持数字的标准运算（加 +、减 -、乘 *、除 /和取模 %），并且，如果需要的话，也可以在不同单位间做转换： 123p &#123; width: 1in + 8pt;&#125; 被编译为： 12p &#123; width: 9in; &#125; 数字也支持关系运算（&lt;、&gt;、&lt;=、&gt;=）， 等式运算（==、!=）被所有数据类型支持。 除法运算和 CSS 允许 / 出现在属性值里，作为分隔数字的一种方法。 既然 SassScript 是 CSS 属性语法的扩展， 他就必须支持这种语法，同时也允许 / 用在除法运算上。 也就是说，默认情况下，在 SassScript 里用 / 分隔的两个数字， 都会在 CSS 中原封不动的输出。 然而，在以下三种情况中，/ 会被解释为除法运算。 这就覆盖了绝大多数真正使用除法运算的情况。 这些情况是： 如果数值或它的任意部分是存储在一个变量中或是函数的返回值。 如果数值被圆括号包围。 如果数值是另一个数学表达式的一部分。 例如： 12345678p &#123; font: 10px/8px; // 纯 CSS，不是除法运算 $width: 1000px; width: $width/2; // 使用了变量，是除法运算 width: round(1.5)/2; // 使用了函数，是除法运算 height: (500px/2); // 使用了圆括号，是除法运算 margin-left: 5px + 8px/2px; // 使用了加（+）号，是除法运算&#125; 被编译为： 123456789101112p &#123; font: 10px/8px; width: 500px; height: 250px; margin-left: 9px; &#125;如果你希望在纯 CSS 中使用变量和 /， 你可以用 #&#123;&#125; 包住变量。 例如：p &#123; $font-size: 12px; $line-height: 30px; font: #&#123;$font-size&#125;/#&#123;$line-height&#125;;&#125; 被编译为： 12p &#123; font: 12px/30px; &#125; 颜色运算 所有算数运算都支持颜色值， 并且是分段运算的。 也就是说，红、绿、蓝各颜色分量会单独进行运算。 例如： 123p &#123; color: #010203 + #040506;&#125; 计算公式为 01 + 04 = 05、02 + 05 = 07 和 03 + 06 = 09， 并且被合成为： 123p &#123; color: #050709; &#125;&#125; 一般 {Sass::Script::Functions color functions} 比颜色运算更有用，并且能达到相同的效果。 算数运算也能将数字和颜色值一起运算，同样也是分段运算的。 例如： 123p &#123; color: #010203 * 2;&#125; 计算公式为 01 2 = 02、02 2 = 04 和 03 * 2 = 06， 并且被合成为： 12p &#123; color: #020406; &#125; 字符串运算 运算符可以用来连接字符串：123p &#123; cursor: e + -resize;&#125; 被编译为： 12p &#123; cursor: e-resize; &#125; 注意，如果有引号的字符串被添加了一个没有引号的字符串 （也就是，带引号的字符串在 + 符号左侧）， 结果会是一个有引号的字符串。 同样的，如果一个没有引号的字符串被添加了一个有引号的字符串 （没有引号的字符串在 + 符号左侧）， 结果将是一个没有引号的字符串。 例如： 1234p:before &#123; content: "Foo " + Bar; font-family: sans- + "serif";&#125; 被编译为： 123p:before &#123; content: "Foo Bar"; font-family: sans-serif; &#125; 默认情况下，如果两个值彼此相邻，它们会被用空格连接起来： 123p &#123; margin: 3px + 4px auto;&#125; 被编译为： 12p &#123; margin: 7px auto; &#125; 在文本字符串中，#{} 形式的表达式可以被用来在字符串中添加动态值： 123p:before &#123; content: "I ate #&#123;5 + 10&#125; pies!";&#125; 被编译为： 12p:before &#123; content: "I ate 15 pies!"; &#125; 空值会被视作空字符串： 1234$value: null;p:before &#123; content: "I ate #&#123;$value&#125; pies!";&#125; 被编译为： 12p:before &#123; content: "I ate pies!"; &#125; 条件判断及循环@if判断 你可能早已知晓，Sass 通过 @if 和 @else 指令提供了条件语句。除非你的代码中有偏复杂的逻辑，否则没必要在日常开发的样式表中使用条件语句。实际上，条件语句主要适用于库和框架。 无论何时，如果你感觉需要它们，请遵守下述准则： 除非必要，不然不需要括号； 务必在 @if 之前添加空行； 务必在左开大括号( { )后换行； @else 语句和它前面的右闭大括号( } )写在同一行； 务必在右闭大括号( } )后添加空行，除非下一行还是右闭大括号( } )，那么就在最后一个右闭大括号( } )后添加空行。 12345p &#123; @if 1 + 1 == 2 &#123; border: 1px solid; &#125; @if 5 &lt; 3 &#123; border: 2px dotted; &#125; @if null &#123; border: 3px double; &#125;&#125; 编译生成: 12p &#123; border: 1px solid; &#125; @if @else结合使用方法 1234567p&#123; @if 1+1==2&#123; width:30px; &#125;@else&#123; width:100px; &#125;&#125; 编译生成: 12p&#123; width:30px;&#125; 三目运算判断 三目运算符的语法为： @if($condition, $condition_true, $condition_false)， 三个参数分别表示：条件，条件为真的值，条件为假的值。 例如： 1234$fontBold: true;p &#123; font-weight: if($fontBold, bold, normal);&#125; 编译生成: 12p &#123; font-weight: bold;&#125; for循环 在 Sass 中，可以使用 @for 循环来完成。在 Sass 的 @for 循环中有两种方式： @for $i from through @for $i from to $i 表示变量 start 表示起始值 end 表示结束值 这两个的区别是关键字 through 表示包括 end 这个数，而 to 则不包括 end 这个数。 如下代码，先来个使用 through 关键字的例子： 123 @for $i from 1 through 3 &#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;&#125; 被编译为： 123456.item-1 &#123; width: 2em; &#125;.item-2 &#123; width: 4em; &#125;.item-3 &#123; width: 6em; &#125; 再来个 to 关键字的例子： 123 @for $i from 1 to 3 &#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;&#125; 编译出来的 CSS: 1234567.item-1 &#123; width: 2em;&#125; .item-2 &#123; width: 4em;&#125; each循环 @each 循环就是去遍历一个列表，然后从列表中取出对应的值。 @each 循环指令的形式： @each $var in &lt; list &gt; 在下面的例子中你可以看到，$var 就是一个变量名，&lt; list &gt; 是一个 SassScript 表达式，他将返回一个列表值。变量 $var 会在列表中做遍历，并且遍历出与 $var 对应的样式块。 这有一个 @each 指令的简单示例： 12345 @each $animal in puma, egret, salamander &#123; .#&#123;$animal&#125;-icon &#123; background-image: url('/course/565c0c2abc27d77730c072b3/img/#&#123;$animal&#125;.png'); &#125;&#125; 被编译为：123456.puma-icon &#123; background-image: url('/course/565c0c2abc27d77730c072b3/img/puma.png'); &#125;.egret-icon &#123; background-image: url('/course/565c0c2abc27d77730c072b3/img/egret.png'); &#125;.salamander-icon &#123; background-image: url('/course/565c0c2abc27d77730c072b3/img/salamander.png'); &#125; while循环 @while 指令也需要 SassScript 表达式（像其他指令一样），并且会生成不同的样式块，直到表达式值为 false 时停止循环。这个和 @for 指令很相似，只要 @while 后面的条件为 true 就会执行。 这里有一个 @while 指令的简单用例：//SCSS12345$i: 6; @while $i &gt; 0 &#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125; $i: $i - 2;&#125; 被编译为：12345678.item-6 &#123; width: 12em; &#125; .item-4 &#123; width: 8em; &#125; .item-2 &#123; width: 4em; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Underscore learning (汇智网 underscore课程)]]></title>
    <url>%2Fblog%2F2017%2F04%2F24%2FUnderscorelearning%2F</url>
    <content type="text"><![CDATA[Underscore快速入门什么是Underscore？ Underscore是一个JavaScript 库，提供了一整套函数式编程的实用功能，但是没有扩展任何JavaScript内置的对象。它弥补了部分jQuery没有实现的功能，同时又是Backbone.js 比不可少的部分。PS: Backbone 和本文无关，我们可能会单独开一门课程来讲解。Underscore 提供了100多个函数，包括常用的each、filter、sortBy等等，还有更加专业的：函数绑定、索引、模版等。当然JavaScript原生的函数也可以实现，但是比较麻烦，我们在学习Underscore的过程中我们会看它是如何实现的。 这样可以让我们更好的理解和学习 Underscore 安装 Underscore.js是一个Javascript功能类库，不依赖于环境，可以加载到HTML中在浏览器运行，也可以直接在nodejs的环境中使用。 前端：把 underscore.js 直接引入到 html 页面中。 示例： 1&lt;script src="underscore.js"&gt;&lt;/script&gt; 后端：环境：nodejs5.0 npm3.6.0后端安装十分的方便，在命令行中输入：npm install underscore使用：var _ = require(‘underscore’); 课程简述 underscore有近100的函数，本课程只介绍一些，比较常见的，实用的函数。主要的内容有：集合部分:数组或对象数组部分函数部分对象部分实用功能链式语法 集合部分（数组或对象）遍历_.each(list, iteratee, [context]) 遍历list中的所有元素，按顺序用遍历输出每个元素。如果传递了context参数，则把iteratee绑定到context对象上。 每次调用iteratee都会传递三个参数：(element, index, list)。如果list是个JavaScript对象，iteratee的参数是 (value, key, list))。返回list以方便链式调用。 12345678_.each([1, 2, 3], alert); =&gt; alerts each number in turn... _.each(&#123;one: 1, two: 2, three: 3&#125;, alert); =&gt; alerts each number value in turn... 注意：集合函数能在数组，对象，和类数组对象，比如arguments, NodeList和类似的数据类型上正常工作。 但是它通过鸭子类型工作，所以要避免传递一个不固定length属性的对象。每个循环不能被破坏打破， 使用_.find(后面的章节会讲解到)代替，这也是很好的注意。 _.map(list, iteratee, [context]) 通过转换函数(iteratee迭代器)映射列表中的每个值产生价值的新数组。 iteratee传递三个参数：value，然后是迭代 index，最后一个是引用指向整个list。 123456789101112_.map([1, 2, 3], function(num)&#123; return num * 3; &#125;); =&gt; [3, 6, 9] _.map(&#123;one: 1, two: 2, three: 3&#125;, function(num, key)&#123; return num * 3; &#125;); =&gt; [3, 6, 9] _.map([[1, 2], [3, 4]], _.first); =&gt; [1, 3] 元素合并reduce_.reduce(list, iteratee, [memo], [context]) reduce方法把list中元素归结为一个单独的数值。 Memo是reduce函数的初始值，reduce的每一步都需要由iteratee返回。这个迭代传递4个参数：memo,value 和 迭代的index（或者 key）和最后一个引用的整个 list。 如果没有memo传递给reduce的初始调用，iteratee不会被列表中的第一个元素调用。第一个元素将取代 传递给列表中下一个元素调用iteratee的memo参数。 123var sum = _.reduce([1, 2, 3], function(memo, num)&#123; return memo + num; &#125;, 0);=&gt; 6 查找和过滤find_.find(list, predicate, [context]) 在list中逐项查找，返回第一个通过predicate迭代函数真值检测的元素值，如果没有值传递给测试迭代器将返回undefined。 如果找到匹配的元素，函数将立即返回，不会遍历整个list。 123var even = _.find([1, 2, 3, 4, 5, 6], function(num)&#123; return num % 2 == 0; &#125;);=&gt; 2 _.filter(list, predicate, [context]) 遍历list中的每个值，返回包含所有通过predicate真值检测的元素值。 123var evens = _.filter([1, 2, 3, 4, 5, 6], function(num)&#123; return num % 2 == 0; &#125;);=&gt; [2, 4, 6] 过滤_.where(list, properties) 遍历list中的每一个值，返回一个数组，这个数组包含properties所列出的属性的所有的 键 &gt; 值对。 12345678910var list = [ &#123;title:"AAA",year: 1982&#125;, &#123;title:"BBB",year: 1900&#125;, &#123;title:"CCC",year: 1982&#125;];console.log( _.where(list,&#123;year: 1982&#125;));=&gt; [ &#123; title: 'AAA', year: 1982 &#125;, &#123; title: 'CCC', year: 1982 &#125; ] 判断和提取_.contains(list, value, [fromIndex]) 判断元素是否在list中，如果list包含指定的value则返回true（愚人码头注：使用===检测）。如果list 是数组，内部使用indexOf判断。使用fromIndex来给定开始检索的索引位置。 1234var b = _.contains([1, 2, 3], 2);console.log(b);=&gt; true _.pluck(list, propertyName) 提取一个集合里指定的属性值，pluck也许是map最常使用的用例模型的简化版本，即萃取数组对象中某属性值，返回一个数组。 1234var stooges = [&#123;name: 'moe', age: 40&#125;, &#123;name: 'larry', age: 50&#125;, &#123;name: 'curly', age: 60&#125;];console.log(_.pluck(stooges, 'name'));=&gt; ["moe", "larry", "curly"] 判断最大最小值_.max(list, [iteratee], [context]) 返回list中的最大值。如果传递iteratee参数，iteratee将作为list中每个值的排序依据。如果list为空，将返回-Infinity，所以你可能需要事先用isEmpty检查 list 。 1234var stooges = [&#123;name: 'moe', age: 40&#125;, &#123;name: 'larry', age: 95&#125;, &#123;name: 'curly', age: 60&#125;];console.log(_.max(stooges, function(stooge)&#123; return stooge.age; &#125;));=&gt; &#123;name: 'curly', age: 60&#125;; _.min(list, [iteratee], [context]) 返回list中的最小值。如果传递iteratee参数，iteratee将作为list中每个值的排序依据。如果list为空，将返回-Infinity，所以你可能需要事先用isEmpty检查 list 。 1234var numbers = [10, 5, 100, 2, 1000,-12];console.log(_.min(numbers));=&gt; 2 sortBy 排序_.sortBy(list, iteratee, [context]) 返回一个排序后的list拷贝副本。如果传递iteratee参数，iteratee将作为list中每个值的排序依据。迭代器也可以是字符串的属性的名称进行排序的(比如 length)。 1234567_.sortBy([1, 2, 3, 4, 5, 6], function(num)&#123; return Math.sin(num); &#125;);=&gt; [5, 4, 6, 3, 1, 2] var stooges = [&#123;name: 'moe', age: 40&#125;, &#123;name: 'larry', age: 50&#125;, &#123;name: 'curly', age: 60&#125;];console.log(_.sortBy(stooges, 'age'));=&gt; [&#123;name: 'curly', age: 60&#125;, &#123;name: 'larry', age: 50&#125;, &#123;name: 'moe', age: 40&#125;]; 转换和获取个数_.toArray(list) 把list(任何可以迭代的对象)转换成一个数组，在转换 arguments 对象时非常有用。 1234console.log(_.toArray(&#123;"one": 1, "two": 2, "three": 3, "fore": 4, "five": 5&#125;)); (function()&#123; return _.toArray(arguments).slice(1); &#125;)(1, 2, 3, 4);=&gt; [2, 3, 4] _.size(list) 返回list的长度。 123console.log(_.size(&#123;"one": 1, "two": 2, "three": 3, "fore": 4, "five": 5&#125;));=&gt; 3 数组部分元素位置操作_.first(array, [n]) 返回array（数组）的第一个元素。传递 n参数将返回数组中从第一个元素开始的n个元素。 123console.log(_.first([5, 4, 3, 2, 1],3));=&gt; 5 _.initial(array, [n]) 返回数组中除了最后一个元素外的其他全部元素。 在arguments对象上特别有用。传递 n参数将从结果中排除从最后一个开始的n个元素 123console.log(_.initial([5, 4, 3, 2, 1],2)); =&gt; [5, 4, 3, 2] _.last(array, [n]) 返回array（数组）的最后一个元素。传递 n参数将返回数组中从最后一个元素开始的n个元素。 123 console.log(_.last([5, 4, 3, 2, 1],2));=&gt; 1 _.rest(array, [index]) 返回数组中除了第一个元素外的其他全部元素。传递 index 参数将返回从index开始的剩余所有元素 。 123console.log(_.rest([5, 4, 3, 2, 1],2));=&gt; [4, 3, 2, 1] 获取索引位置_.indexOf(array, value, [isSorted]) 返回value在该 array 中的索引值，如果value不存在 array中就返回-1。使用原生的indexOf 函数，除非它失效。 如果您正在使用一个大数组，你知道数组已经排序，传递true给isSorted将更快的用二进制搜索..,或者，传递一个数字作为第三个参数，为了在给定的索引的数组中寻找第一个匹配值。 123console.log(_.indexOf([1, 2, 3], 2)); =&gt; 1 _.lastIndexOf(array, value, [fromIndex]) 返回value在该 array 中的从最后开始的索引值，如果value不存在 array中就返回-1。 如果支持原生的lastIndexOf，将使用原生的lastIndexOf函数。传递fromIndex将从你给定的索性值开始搜索。 123console.log(_.lastIndexOf([1, 2, 3, 1, 2, 3], 2)); =&gt; 4 _.sortedIndex(list, value, [iteratee], [context]) 使用二分查找确定value在list中的位置序号，value按此序号插入能保持list原有的排序。 如果提供iterator函数，iterator将作为list排序的依据，包括你传递的value 。iterator也可以是字符串的属性名用来排序(比如length)。 1234567 console.log(_.sortedIndex([10, 20, 30, 40, 50], 31));=&gt; 3 var stooges = [&#123;name: 'moe', age: 40&#125;, &#123;name: 'curly', age: 60&#125;];console.log(_.sortedIndex(stooges, &#123;name: 'larry', age: 50&#125;, 'age'));=&gt; 1 去除空值和嵌套_.compact(array) 返回一个除去所有false值的 array副本。 在javascript中, false, null, 0, “”, undefined 和 NaN 都是false值. 123console.log(_.compact([0, 1, false, 2, '', 3]));=&gt; [1, 2, 3] _.flatten(array, [shallow]) 将一个嵌套多层的数组 array（数组） (嵌套可以是任何层数)转换为只有一层的数组。 如果你传递 shallow参数，数组将只减少一维的嵌套。 123456console.log(_.flatten([1, [2], [3, [[4]]]])); =&gt; [1, 2, 3, 4]; console.log(_.flatten([1, [2], [3, [[4]]]], true)); =&gt; [1, 2, 3, [[4]]]; 范围整数数组_.range([start], stop, [step]) 一个用来创建整数灵活编号的列表的函数，便于each 和 map循环。 如果省略start则默认为 0；step 默认为 1.返回一个从start 到stop的整数的列表，用step来增加 （或减少）独占。 值得注意的是，如果stop值在start前面（也就是stop值小于start值），那么值域会被认为是零长度，而不是负增长。-如果你要一个负数的值域 ，请使用负数step. 1234567891011console.log(_.range(10)); =&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]console.log(_.range(1, 11)); =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]console.log(_.range(0, 30, 5)); =&gt; [0, 5, 10, 15, 20, 25]console.log(_.range(0, -10, -1)); =&gt; [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]console.log(_.range(0)); =&gt; [] 合并和转换_.zip(*arrays) 将每个arrays中相应位置的值合并在一起。在合并分开保存的数据时很有用. 如果你用来处理矩阵嵌套数组时, _.zip.apply 可以做类似的效果。 1234console.log(_.zip(['moe', 'larry', 'curly'], [30, 40, 50], [true, false, false]));=&gt; [["moe", 30, true], ["larry", 40, false], ["curly", 50, false]] _.object(list, [values]) 将数组转换为对象。传递任何一个单独[key, value]对的列表，或者一个键的列表和一个值得列表。 如果存在重复键，最后一个值将被返回。 123456console.log(_.object(['moe', 'larry', 'curly','moe'], [35, 40, 50,30])); =&gt; &#123;moe: 30, larry: 40, curly: 50&#125; console.log(_.object([['moe', 30], ['larry', 40], ['curly', 50]])); =&gt; &#123;moe: 30, larry: 40, curly: 50&#125; 函数部分绑定函数bind: 绑定函数到对象上, 无论何时函数被调用, 函数里的this都指向对象. 12345var func = function(greeting)&#123; return greeting + ': ' + this.name &#125;;func = _.bind(func, &#123;name : 'moe'&#125;, 'hi');console.log(func());=&gt; hi: moe bindAll: 绑定方法名到对象上, 当这些方法被执行时将在对象的上下文执行. 绑定函数用作事件处理时非常方便, 否则函数调用时 this 关键字根本没什么用. 123456789 var buttonView = &#123; label : 'underscore', onClick : function()&#123; console.log('clicked: ' + this.label); &#125;, onHover : function()&#123; console.log('hovering: ' + this.label); &#125;&#125;;var func = _.bindAll(buttonView, 'onClick', 'onHover');func.onClick();=&gt; clicked: underscore 填充数据partial: 局部应用一个函数填充在任意个数的 arguments，不改变其动态this值。和bind方法很相近。你可以传递_ 给arguments列表来指定一个不预先填充，但在调用时提供的参数。 12345var add = function(a, b) &#123; return a + b; &#125;;add5 = _.partial(add, 5);console.log(add5(10));=&gt; 15 记忆函数绑定函数 _.memoize(function, [hashFunction]) Memoizes方法可以缓存某函数的计算结果。对于耗时较长的计算是很有帮助的。 如果传递了 hashFunction 参数，就用 hashFunction 的返回值作为key存储函数的计算结果。 hashFunction 默认使用function的第一个参数作为key。memoized值的缓存可作为返回函数的cache属性。 123456var fibonacci = _.memoize(function(n) &#123; return n &lt; 2 ? n: fibonacci(n - 1) + fibonacci(n - 2);&#125;);console.log(fibonacci(30)); delay 和 deferdelay: 在等待xx毫秒之后调用函数，类似于setTimeout 1234var log = _.bind(console.log, console);_.delay(log, 1000, 'sleep 1s');=&gt; sleep 1s defer: 延迟调用函数, 直到当前调用栈被清空为止, 跟使用 setTimeout 赋予0毫秒的延时很像。 对执行高消耗算法或大型HTML呈现而不阻碍UI更新线程很有用. 123_.defer(function()&#123; console.log('deferred'); &#125;); =&gt; deferred after 和 before_.after(count, function) 对循环计数，只有超过计数，才会调用指定的函数 1234567891011121314var nums = [1,2,3,4];var renderNums = _.after(nums.length, function()&#123; console.log('render nums');&#125;);_.each(nums, function(num) &#123; console.log('each:'+num); renderNums();&#125;);=&gt; each:1each:2each:3each:4render nums _.before(count, function) 创建一个函数,调用不超过count 次。 当count已经达到时，最后一个函数调用的结果将被记住并返回。 12345var monthlyMeeting = _.before(3, askForRaise);monthlyMeeting();monthlyMeeting();monthlyMeeting(); 函数传递_.wrap(function, wrapper) 将第一个函数 function 封装到函数 wrapper 里面, 并把函数 function 作为第一个参数传给 wrapper. 这样可以让 wrapper 在 function 运行之前和之后 执行代码, 调整参数然后附有条件地执行. 1234567var hello = function(name) &#123; return "hello: " + name; &#125;;hello = _.wrap(hello, function(func) &#123; return "before, " + func("moe") + ", after";&#125;);console.log(hello());=&gt; 'before, hello: moe, after' 对象部分keys 和 values_.keys(object) 检索object拥有的所有可枚举属性的名称。 1234console.log(_.keys(&#123;one: 1, two: 2, three: 3&#125;));=&gt; ["one", "two", "three"]_.allKeys(object) 检索object拥有的和继承的所有属性的名称。 1234567function Stooge(name) &#123; this.name = name;&#125;Stooge.prototype.silly = true;console.log(_.allKeys(new Stooge("Moe")));=&gt; ["name", "silly"] _.values(object) 返回object对象所有的属性值。 123console.log(_.values(&#123;one: 1, two: 2, three: 3&#125;)); =&gt; [1, 2, 3] 对象遍历_.mapObject(object, iteratee, [context]) 它类似于map，但是这用于对象。转换每个属性的值。 12345console.log(_.mapObject(&#123;start: 5, end: 12&#125;, function(val, key) &#123; return val + 5;&#125;));=&gt; &#123;start: 10, end: 17&#125; 转换和对调 _.pairs(object) 把一个对象转变为一个[key, value]形式的数组。 123console.log(_.pairs(&#123;one: 1, two: 2, three: 3&#125;));=&gt; [["one", 1], ["two", 2], ["three", 3]] _.invert(object) 返回一个object副本，使其键（keys）和值（values）对换。对于这个操作，必须确保object里所有的值都是唯一的且可以序列号成字符串. 123console.log(_.invert(&#123;Moe: "Moses", Larry: "Louis", Curly: "Jerome"&#125;)); =&gt; &#123;Moses: "Moe", Louis: "Larry", Jerome: "Curly"&#125;; 复制extend: 复制对象的所有属性到目标对象上，覆盖已有属性 12345console.log( _.extend(&#123;name : 'moe',age:45&#125;, &#123;age : 50&#125;));=&gt; &#123; name: 'moe', age: 50 &#125; defaults: 复制对象的所有属性到目标对象上，跳过已有属性 123456var iceCream = &#123;flavor : "chocolate"&#125;;console.log( _.defaults(iceCream, &#123;flavor : "vanilla", sprinkles : "lots"&#125;));=&gt; &#123; flavor: 'chocolate', sprinkles: 'lots' &#125; clone: 引入方式克隆对象，不进行复制 12345console.log( _.clone(&#123;name : 'moe'&#125;));=&gt; &#123;name : 'moe'&#125;; tag: 用对象作为参数来调用函数，作为函数链式调用的一环 12345678910console.log( _.chain([1,2,3,200]) .filter(function(num) &#123; return num % 2 == 0; &#125;) .tap(console.log) .map(function(num) &#123; return num * num &#125;) .value());=&gt; [ 2, 200 ][ 4, 40000 ] 比较_.isEqual(object, other) 执行两个对象之间的优化深度比较，确定他们是否应被视为相等。 1234567 var stooge = &#123;name: 'moe', luckyNumbers: [13, 27, 34]&#125;; var clone = &#123;name: 'moe', luckyNumbers: [13, 27, 34]&#125;; console.log(stooge == clone); =&gt; falseconsole.log(_.isEqual(stooge, clone)); =&gt; true 实用功能改变命名空间 Underscore默认使用_（下划线）来访问和创建对象，但这个名字可能不符合我们的命名规范，或容易引起命名冲突。 _.noConflict() 我们可以通过noConflict()方法来改变Underscore的命名，并恢复_（下划线）变量之前的值，例如： 1234567//Underscore对象 console.dir(_); 将Underscore对象重命名为us, 后面都通过us来访问和创建Underscore对象 var us = _.noConflict(); 输出"自定义变量" console.dir(_); 随机数 _.random(min, max) 返回一个min 和 max之间的随机整数。如果你只传递一个参数，那么将返回0和这个参数之间的整数。 123 console.log(_.random(0, 100));=&gt; 42 唯一ID _.uniqueId([prefix]) 为需要的客户端模型或DOM元素生成一个全局唯一的id。如果prefix参数存在， id 将附加给它。 123console.log(_.uniqueId('contact_1'));=&gt; 'contact_104' 扩展 允许用您自己的实用程序函数扩展Underscore。传递一个 {name: function}定义的哈希添加到Underscore对象，以及面向对象封装。 12345678_.mixin(&#123; capitalize : function(string) &#123; return string.charAt(0).toUpperCase() + string.substring(1).toLowerCase(); &#125;&#125;);console.log(_("fabio").capitalize());=&gt; Fabio 返回属性值 _.result(object, property, [defaultValue]) 如果指定的 property 的值是一个函数，那么将在object上下文内调用它;否则，返回它。 如果提供默认值，并且属性不存在，那么默认值将被返回。如果设置defaultValue是一个函数，它的结果将被返回。 12345678var object = &#123;cheese: 'crumpets', stuff: function()&#123; return 'nonsense'; &#125;&#125;;console.log(_.result(object, 'cheese'));=&gt; "crumpets"_.result(object, 'stuff');=&gt; "nonsense"_.result(object, 'meat', 'ham');=&gt; "ham" 链式语法chain 如果你用过jQuery，那么应该对链式操作非常熟悉了。链式操作写起来非常顺畅，代码也会非常的语义化。 Underscore.js中也支持将代码写成链式的，API为chain，chain返回的是一个包装过的underscore对象，到链结束的时候，需要调用value来获取最终的结果： 123456789var stooges = [&#123;name: 'curly', age: 25&#125;, &#123;name: 'moe', age: 21&#125;, &#123;name: 'larry', age: 23&#125;];var youngest = _.chain(stooges) .sortBy(function(stooge)&#123; return stooge.age; &#125;) .map(function(stooge)&#123; return stooge.name + ' is ' + stooge.age; &#125;) .first() .value();console.log(youngest);=&gt; "moe is 21" value_(obj).value() 获取封装对象的最终值. 1234var value = _([1, 2, 3]).value();console.log(value);=&gt; [1, 2, 3] 在使用Underscore.js提供的众多API之后，我们自己也是可以写出非常简洁，表意的代码来，是不是很有成就感。]]></content>
  </entry>
  <entry>
    <title><![CDATA[VMware-所有版本永久许可证秘钥]]></title>
    <url>%2Fblog%2F2017%2F02%2F13%2F2017-02-13%2F</url>
    <content type="text"><![CDATA[永久许可证秘钥：VMware Workstation v12 for Windows 5A02H-AU243-TZJ49-GTC7K-3C61N VMware Workstation v11 for Windows 1F04Z-6D111-7Z029-AV0Q4-3AEH8 VMware Workstation v10 for Windows 1Z0G9-67285-FZG78-ZL3Q2-234JG 4C4EK-89KDL-5ZFP9-1LA5P-2A0J0 HY086-4T01N-CZ3U0-CV0QM-13DNU VMware Workstation v9 for Windows 4U434-FD00N-5ZCN0-4L0NH-820HJ 4V0CP-82153-9Z1D0-AVCX4-1AZLV 0A089-2Z00L-AZU40-3KCQ2-2CJ2T VMware Workstation v8 for Windows A61D-8Y0E4-QZTU0-ZR8XP-CC71Z MY0E0-D2L43-6ZDZ8-HA8EH-CAR30 MA4XL-FZ116-NZ1C9-T2C5K-AAZNR VMware Workstation v7 for Windows VZ3X0-AAZ81-48D4Z-0YPGV-M3UC4 VU10H-4HY97-488FZ-GPNQ9-MU8GA ZZ5NU-4LD45-48DZY-0FNGE-X6U86 VMware Workstation v6 for Windows UV16D-UUC6A-49H6E-4E8DY C3J4N-3R22V-J0H5R-4NWPQ A15YE-5250L-LD24E-47E7C VMware Workstation v6 ACE Edition for Windows TK08J-ADW6W-PGH7V-4F8FP YJ8YH-6D4F8-9EPGV-4DZNA YCX8N-4MDD2-G130C-4GR4L]]></content>
  </entry>
  <entry>
    <title><![CDATA[《软技能 代码之外的生存指南》这本书中的书籍推荐]]></title>
    <url>%2Fblog%2F2017%2F02%2F10%2F2017-02-09%2F</url>
    <content type="text"><![CDATA[《软技能 代码之外的生存指南》这本书中的书籍推荐：1.自我提升和励志类图书Steven Pressfield的The War of Art［Black Irish Books，2002］Dale Carnegie的《人性的弱点》（How to Win Friends and Influence People）［Gallery Books，1998再版］Napoleon Hill的 《思考致富》 （Think and Grow Rich） ［Wilder Publications，2007］Maxwell Maltz的《心理控制方法》（Psycho-Cybernetics）［Pocket Books，1989再版］Norman Vincent Peale的《积极思考就是力量》（The Power of Positive Thinking）［Touchstone，2003再版］Ayn Rand的《阿特拉斯耸耸肩》（Atlas Shrugged）［Signet，2005再版］2.软件开发类图书Steve McConnell的 《代码大全》 （Code Complete） ［Microsoft Press，2004］Robert Martin的《代码整洁之道》（Clean Code: A Handbook of Agile Software Craftmanship）［Prentice Hall，2008］Eric Freeman、Elisabeth Robson、Bert Bates和Kathy Sierra的 《Head First设计模式》（Head First Design Patterns）［O’Reilly Media，2004］3.投资类图书Gary Keller的The Millionaire Real Estate Investor［McGraw-Hill，2005］Robert Kiyosaki的《富爸爸，穷爸爸》（Rich Dad,Poor Dad）［Demco Media，2000］Kerry Given的No-Hype Options Trading: Myths, Realities, and Strategies That Really__Work［Wiley，2011］]]></content>
  </entry>
  <entry>
    <title><![CDATA[Markdown-语法手册及软件注册码]]></title>
    <url>%2Fblog%2F2017%2F02%2F10%2F2016-12-22%2F</url>
    <content type="text"><![CDATA[http://blog.leanote.com/post/freewalk/Markdown-语法手册#title-3 MarkdownPad2.5 注册码12345678···邮箱：Soar360@live.com授权秘钥：GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ== ··· [MySQL批量删除指定前缀表]http://www.cnblogs.com/haocool/archive/2013/06/25/3153984.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[webstorm破解]]></title>
    <url>%2Fblog%2F2017%2F02%2F10%2F2017-01-10%2F</url>
    <content type="text"><![CDATA[webstorm破解（亲测可用）参考文章：http://blog.csdn.net/it_talk/article/details/52448597 2016.2.3 版本的破解方式： 目前最新的就是2.3版本，在打开的License Activation窗口中选择“activation code”，在输入框输入下面的注册码143B4A73YYJ-eyJsaWNlbnNlSWQiOiI0M0I0QTczWVlKIiwibGljZW5zZWVOYW1lIjoibGFuIHl1IiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJwYWlkVXBUbyI6IjIwMTctMDItMjUifSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjAxNy0wMi0yNSJ9LHsiY29kZSI6IkRQTiIsInBhaWRVcFRvIjoiMjAxNy0wMi0yNSJ9LHsiY29kZSI6IlBTIiwicGFpZFVwVG8iOiIyMDE3LTAyLTI1In0seyJjb2RlIjoiRE0iLCJwYWlkVXBUbyI6IjIwMTctMDItMjUifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjAxNy0wMi0yNSJ9LHsiY29kZSI6IlJTMCIsInBhaWRVcFRvIjoiMjAxNy0wMi0yNSJ9LHsiY29kZSI6IlJDIiwicGFpZFVwVG8iOiIyMDE3LTAyLTI1In0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMTctMDItMjUifSx7ImNvZGUiOiJSTSIsInBhaWRVcFRvIjoiMjAxNy0wMi0yNSJ9LHsiY29kZSI6IldTIiwicGFpZFVwVG8iOiIyMDE3LTAyLTI1In0seyJjb2RlIjoiREIiLCJwYWlkVXBUbyI6IjIwMTctMDItMjUifSx7ImNvZGUiOiJEQyIsInBhaWRVcFRvIjoiMjAxNy0wMi0yNSJ9XSwiaGFzaCI6IjMzOTgyOTkvMCIsImdyYWNlUGVyaW9kRGF5cyI6MCwiYXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwiaXNBdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlfQ==-keaxIkRgXPKE4BR/ZTs7s7UkP92LBxRe57HvWamu1EHVXTcV1B4f/KNQIrpOpN6dgpjig5eMVMPmo7yMPl+bmwQ8pTZaCGFuLqCHD1ngo6ywHKIQy0nR249sAUVaCl2wGJwaO4JeOh1opUx8chzSBVRZBMz0/MGyygi7duYAff9JQqfH3p/BhDTNM8eKl6z5tnneZ8ZG5bG1XvqFTqWk4FhGsEWdK7B+He44hPjBxKQl2gmZAodb6g9YxfTHhVRKQY5hQ7KPXNvh3ikerHkoaL5apgsVBZJOTDE2KdYTnGLmqxghFx6L0ofqKI6hMr48ergMyflDk6wLNGWJvYHLWw==-MIIEPjCCAiagAwIBAgIBBTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE1MTEwMjA4MjE0OFoXDTE4MTEwMTA4MjE0OFowETEPMA0GA1UEAwwGcHJvZDN5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQC9WZuYgQedSuOc5TOUSrRigMw4/+wuC5EtZBfvdl4HT/8vzMW/oUlIP4YCvA0XKyBaCJ2iX+ZCDKoPfiYXiaSiH+HxAPV6J79vvouxKrWg2XV6ShFtPLP+0gPdGq3x9R3+kJbmAm8w+FOdlWqAfJrLvpzMGNeDU14YGXiZ9bVzmIQbwrBA+c/F4tlK/DV07dsNExihqFoibnqDiVNTGombaU2dDup2gwKdL81ua8EIcGNExHe82kjF4zwfadHk3bQVvbfdAwxcDy4xBjs3L4raPLU3yenSzr/OEur1+jfOxnQSmEcMXKXgrAQ9U55gwjcOFKrgOxEdek/Sk1VfOjvS+nuM4eyEruFMfaZHzoQiuw4IqgGc45ohFH0UUyjYcuFxxDSU9lMCv8qdHKm+wnPRb0l9l5vXsCBDuhAGYD6ss+Ga+aDY6f/qXZuUCEUOH3QUNbbCUlviSz6+GiRnt1kA9N2Qachl+2yBfaqUqr8h7Z2gsx5LcIf5kYNsqJ0GavXTVyWh7PYiKX4bs354ZQLUwwa/cG++2+wNWP+HtBhVxMRNTdVhSm38AknZlD+PTAsWGu9GyLmhti2EnVwGybSD2Dxmhxk3IPCkhKAK+pl0eWYGZWG3tJ9mZ7SowcXLWDFAk0lRJnKGFMTggrWjV8GYpw5bq23VmIqqDLgkNzuoog==]]></content>
  </entry>
  <entry>
    <title><![CDATA[Node服务器端开发第三天]]></title>
    <url>%2Fblog%2F2016%2F12%2F08%2Fnode-third%2F</url>
    <content type="text"><![CDATA[核心模块和NPM、文件操作、文件流、网络操作 核心模块核心模块的意义 如果只是在服务器运行JavaScript代码，意义并不大，因为无法实现任何功能（读写文件，访问网络）。 Node 的用处在于它本身还提供的一系列功能模块，用于与操作系统互动。 这些核心的功能模块在 Node 中内置。 内置如下模块： path：处理文件路径。 fs：操作文件系统。 child_process：新建子进程。 util：提供一系列实用小工具。 http：提供HTTP服务器功能。 url：用于解析URL。 querystring：解析URL中的查询字符串。 crypto：提供加密和解密功能。 其他 Node Package 由于Node是一套轻内核的平台，虽然提供了一系列的内置模块，但是不足以满足开发者的需求，于是乎出现了包（Package）的概念。与核心模块类似，就是将一些预先设计好的功能或者说API封装到一个文件夹，提供给开发者使用； 包的加载机制 与内置模块相同，包的加载同样使用require方法 1const express = require('express'); 加载机制也和内置模块加载机制相同 加载注意事项： 先在系统核心（优先级最高）的模块中找； 12const fs = require('fs');// 永远加载内部核心模块fs 然后再到当前项目中 node_modules 目录中找； 如何管理好自己的包包 由于Node本身并没有太多的功能性API，所以市面上涌现出大量的第三方人员开发出来的Package 包的生态圈一旦繁荣起来，就必须有工具去代替人脑或者文档的方式管理 这时候NPM诞生了 NPM 随着时间的发展，NPM 出现了两层概念： 一层含义是 Node 的开放式模块登记和管理系统，亦可以说是一个生态圈，一个社区 另一层含义是 Node 默认的模块管理器，是一个命令行下的软件，用来安装和管理 Node 模块。 官方链接： https://www.npmjs.com/ 国内加速镜像： https://npm.taobao.org/ 安装NPM NPM 不需要单独安装。默认在安装 Node 的时候，会连带一起安装 NPM。 但是，Node 附带的 NPM 可能不是最新版本，最好用下面的命令，更新到最新版本。 1$ npm install npm -g 默认安装到当前系统 Node 所在目录下。 由于之前使用 NVM 的方式安装的 Node 所以需要重新配置 NPM 的全局目录 配置NPM的全局目录1$ npm config set prefix [pathtonpm] 将NPM目录配置到其他目录时，必须将该目录放到环境变量中，否则无法再全局使用 常用NPM命令 https://docs.npmjs.com/ 1234567891011npm config [ls|list|set|get] [name] [value]npm init [--yes|-y]npm search [name]npm info [name]npm install [--global|-g] [name]npm uninstall [--global|-g] [name]npm list [--global|-g]npm outdated [--global|-g]npm update [--global|-g] [name]npm run [task]npm cache [clean] 文件操作相关模块Node内核提供了很多与文件操作相关的模块，每个模块都提供了一些最基本的操作API，在NPM中也有社区提供的功能包 fs：基础的文件操作 API path：提供和路径相关的操作 API readline：用于读取大文本文件，一行一行读 fs-extra（第三方）：https://www.npmjs.com/package/fs-extra 同步或异步调用 fs模块对文件的几乎所有操作都有同步和异步两种形式 例如：readFile() 和 readFileSync() 区别： 同步调用会阻塞代码的执行，异步则不会 异步调用会将读取任务下达到任务队列，直到任务执行完成才会回调 异常处理方面，同步必须使用 try catch 方式，异步可以通过回调函数的第一个参数 123456789101112131415console.time('sync');try &#123; var data = fs.readFileSync(path.join('C:\\Users\\iceStone\\Downloads', 'H.mp4')); // console.log(data);&#125; catch (error) &#123; throw error;&#125;console.timeEnd('sync');console.time('async');fs.readFile(path.join('C:\\Users\\iceStone\\Downloads', 'H.mp4'), (error, data) =&gt; &#123; if (error) throw error; // console.log(data);&#125;);console.timeEnd('async'); 路径模块在文件操作的过程中，都必须使用物理路径（绝对路径），path模块提供了一系列与路径相关的 API 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879console.log('join用于拼接多个路径部分，并转化为正常格式');const temp = path.join(__dirname, '..', 'lyrics', './友谊之光.lrc');console.log(temp);console.log('获取路径中的文件名');console.log(path.basename(temp));console.log('获取路径中的文件名并排除扩展名');console.log(path.basename(temp, '.lrc'));console.log('====================================');console.log('获取不同操作系统的路径分隔符');console.log(process.platform + '的分隔符为 ' + path.delimiter);console.log('一般用于分割环境变量');console.log(process.env.PATH.split(path.delimiter));console.log('====================================');console.log('获取一个路径中的目录部分');console.log(path.dirname(temp));console.log('====================================');console.log('获取一个路径中最后的扩展名');console.log(path.extname(temp));console.log('====================================');console.log('将一个路径解析成一个对象的形式');const pathObject = path.parse(temp);console.log(pathObject);console.log('====================================');console.log('将一个路径对象再转换为一个字符串的形式');// pathObject.name = '我终于失去了你';pathObject.base = '我终于失去了你.lrc';console.log(pathObject);console.log(path.format(pathObject));console.log('====================================');console.log('获取一个路径是不是绝对路径');console.log(path.isAbsolute(temp));console.log(path.isAbsolute('../lyrics/爱的代价.lrc'));console.log('====================================');console.log('将一个路径转换为当前系统默认的标准格式，并解析其中的./和../');console.log(path.normalize('c:/develop/demo\\hello/../world/./a.txt'));console.log('====================================');console.log('获取第二个路径相对第一个路径的相对路径');console.log(path.relative(__dirname, temp));console.log('====================================');console.log('以类似命令行cd命令的方式拼接路径');console.log(path.resolve(temp, 'c:/', './develop', '../application'));console.log('====================================');console.log('获取不同平台中路径的分隔符（默认）');console.log(path.sep);console.log('====================================');console.log('允许在任意平台下以WIN32的方法调用PATH对象');// console.log(path.win32);console.log(path === path.win32);console.log('====================================');console.log('允许在任意平台下以POSIX的方法调用PATH对象');console.log(path === path.posix); 源码地址：https://github.com/nodejs/node/blob/master/lib/path.js 文件读取Node中文件读取的方式主要有： fs.readFile(file[, options], callback(error, data))1234fs.readFile('c:\\demo\1.txt', 'utf8', (err, data) =&gt; &#123; if (err) throw err; console.log(data);&#125;); fs.readFileSync(file[, options])1234567try &#123; const data = fs.readFileSync('c:\\demo\1.txt', 'utf8'); console.log(data);&#125; catch(e) &#123; // 文件不存在，或者权限错误 throw e;&#125; fs.createReadStream(path[, options])12345678const stream = fs.createReadStream('c:\\demo\1.txt');let data = ''stream.on('data', (trunk) =&gt; &#123; data += trunk;&#125;);stream.on('end', () =&gt; &#123; console.log(data);&#125;); 由于Windows平台下默认文件编码是GBK，在Node中不支持，可以通过iconv-lite解决 Readline模块逐行读取文本内容12345678910const readline = require('readline');const fs = require('fs');const rl = readline.createInterface(&#123; input: fs.createReadStream('sample.txt')&#125;);rl.on('line', (line) =&gt; &#123; console.log('Line from file:', line);&#125;); 文件写入Node中文件写入的方式主要有： fs.writeFile(file, data[, options], callback(error))123fs.writeFile('c:\\demo\a.txt', new Date(), (error) =&gt; &#123; console.log(error);&#125;); fs.writeFileSync(file, data[, options])123456try &#123; fs.writeFileSync('c:\\demo\a.txt', new Date());&#125; catch (error) &#123; // 文件夹不存在，或者权限错误 console.log(error);&#125; fs.createWriteStream(path[,option])123456var streamWriter = fs.createWriteStream('c:\\demo\a.txt');setInterval(() =&gt; &#123; streamWriter.write(`$&#123;new Date&#125;\n`, (error) =&gt; &#123; console.log(error); &#125;);&#125;, 1000); 文件写入fs.appendFile(file,data[,options],callback(err))123456// 相比较之前文件流的方式，这种方式不会占用文件资源，append完成就会释放setInterval(() =&gt; &#123; fs.appendFile('c:\\demo\a.txt',`$&#123;new Date&#125;\n`, (error) =&gt; &#123; console.log(error); &#125;);&#125;, 1000); fs.appendFileSync(file,data[,options])123setInterval(() =&gt; &#123; fs.appendFileSync('c:\\demo\a.txt',`$&#123;new Date&#125;\n`);&#125;, 1000); 其他常见文件操作验证路径是否存在（过时的API） fs.exists(path,callback(exists)) fs.existsSync(path) // =&gt; 返回布尔类型 exists 获取文件信息 fs.stat(path,callback(err,stats)) fs.statSync(path) // =&gt; 返回一个fs.Stats实例 移动文件或重命名文件或目录 与命令行相同，重命名操作也可以实现文件移动 fs.rename(oldPath,newPath,callback) fs.renameSync(oldPath,newPath) 删除文件 fs.unlink(path,callback(err)) fs.unlinkSync(path) 其他常见文件夹操作创建一个目录 fs.mkdir(path[,model],callback) fs.mkdirSync(path[,model]) 删除一个空目录 fs.rmdir(path,callback) fs.rmdirSync(path) 读取一个目录 fs.readdir(path,callback(err,files)) fs.readdirSync(path) // =&gt; 返回files 文件监视利用文件监视实现自动 markdown 文件转换 相关链接： https://github.com/chjj/marked https://github.com/Browsersync/browser-sync 实现思路： 利用fs模块的文件监视功能监视指定MD文件 当文件发生变化后，借助marked包提供的markdown to html功能将改变后的MD文件转换为HTML 再将得到的HTML替换到模版中 最后利用BrowserSync模块实现浏览器自动刷新 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const fs = require('fs');const path = require('path');var marked = require('marked');var bs = require('browser-sync').create();var target = path.join(__dirname, process.argv[2] || './README.md');var filename = path.basename(target, path.extname(target)) + '.html';var targetHtml = path.join(path.dirname(target), filename);bs.init(&#123; server: path.dirname(target), index: filename, notify: false&#125;);bs.reload(filename);var template = `&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt;&#123;&#123;&#123;styles&#125;&#125;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;article class="markdown"&gt; &#123;&#123;&#123;body&#125;&#125;&#125; &lt;/article&gt;&lt;/body&gt;&lt;/html&gt;`;fs.readFile(path.join(__dirname, './markdown.css'), 'utf8', (error, css) =&gt; &#123; if (error) throw error; template = template.replace('&#123;&#123;&#123;styles&#125;&#125;&#125;', css); var handler = (current, previous) =&gt; &#123; fs.readFile(target, 'utf8', (error, content) =&gt; &#123; var html = template.replace('&#123;&#123;&#123;body&#125;&#125;&#125;', marked(content)); fs.writeFile(targetHtml, html, (error) =&gt; &#123; if (!error) &#123; console.log(`updated@$&#123;new Date()&#125;`); bs.reload(filename); &#125; &#125;); &#125;); &#125;; handler(); fs.watchFile(target, &#123; interval: 100 &#125;, handler);&#125;); 缓冲区处理什么是缓冲区 缓冲区就是内存中操作数据的容器 只是数据容器而已 通过缓冲区可以很方便的操作二进制数据 而且在大文件操作时必须有缓冲区 为什么要有缓冲区 JavaScript是比较擅长处理字符串，但是早期的应用场景主要用于处理HTML文档，不会有太大篇幅的数据处理，也不会接触到二进制的数据。 而在Node中操作数据、网络通信是没办法完全以字符串的方式操作的，简单来说 所以在Node中引入了一个二进制的缓冲区的实现：Buffer 文件流 网络操作]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTML5 基础]]></title>
    <url>%2Fblog%2F2016%2F11%2F29%2Fhtml5-note%2F</url>
    <content type="text"><![CDATA[HTML5 肯定不是多了一些标签就完事了 HTML5 根酷炫没什么关系，更多的职责是功能，而不是外观 1. 概要1.1. WEB技术阶段 Web 1.0 内容为主，主要流行HTML和CSS Web 2.0 动态网页，流行AJAX/JavaScript/DOM HTML5 时代，WEB开发回归富客户端 1.2. 什么是HTML5 是HTML的超集，不仅仅是HTML，更多的是JavaScript API和CSS的提升， 构建 Web 应用程序整体解决方案 API的概念就是我们编程时所依赖的东西的总称 1.3. 什么是Web Application HTML5 前身，由WHATWG组织提出 推出的目的主要是提高Web应用程序的功能 2007年提交到W3C组织，成了现在我们看到的HTML5 1.4. HTML5应用场景 极具表现力的网页 案例非常多 网页应用程序 PC端：iCloud、百度脑图、Office 365··· APP端：淘宝、京东、美团··· WeChat端：淘宝、京东、美团··· 混合式本地应用 PC端：网易云音乐、有道词典··· APP端：淘宝、京东、美团··· 简单的游戏 1.5. H5新特性概要 我们这里只是列出了H5中所有的新特性，大部分内容会在以后的课程中专门学习 1.5.1. HTML 标签 更语义化标签 智能表单 新的表单类型，如：email,url,number 新增表单功能属性，如：autocomplete，autofocus 虚拟键盘适配，通过表单的类型决定移动端弹出的键盘类型 网页多媒体，我们可以在网页中直接通过原生方式播放视频音频 音频 视频 字幕 属性，语义化属性，在移动Web bootstrap的课程中用到 链接关系描述 结构数据标记 ARIA 自定义属性 Canvas，提供网页绘图的可能，后面在Canvas课程会专门去学习 2D 绘图 3D (WebGL) SVG，仅仅了解即可 1.5.2. JavaScript API 核心平台提升，JS在DOM和BOM两个方向上都新增了很多api，便于开发应用程序 新的选择器 Element.classList 访问历史API 全屏API 网页存储，提供网页中操作客户端本地存储的API Application Cache localStorage sessionStorage WebSQL IndexedDB 设备信息访问，JS可以访问硬件的一些信息，我们在移动手机APP的课程中再看 网络状态 硬件访问 设备方向 地理围栏 拖放操作 网页内拖放 桌面拖入 文件 文件系统API FileReader 网络访问，后面AJAX和服务端编程的课程再去看 XMLHttpRequest fetch WebSocket 多线程 桌面通知 1.5.3. CSS 后面详细讨论 1.6. HTML5 骨架1234567891011121314&lt;!-- HTML5的DOCTYPE声明做了最大简化 --&gt;&lt;!DOCTYPE html&gt;&lt;!-- lang属性根据当前网页大量使用的语言种类决定，大量使用中文则使用zh-CN，英文则使用en --&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;!-- 在标准的HTML5骨架中charset是直接在meta中设置charset --&gt; &lt;!-- 字符编码的设置一定是在head中的第一行 --&gt; &lt;title&gt;页面标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; HTML5的DOCTYPE声明做了最大简化 在标准的HTML5骨架中charset是直接在meta中设置charset 字符编码的设置一定是在head中的第一行，再晚就来不及了 lang属性根据当前网页大量使用的语言种类决定，大量使用中文则使用zh-CN，英文则使用en 2. 语义化标签2.1. 什么是语义化标签 HTML5中制定了一系列语义化标签： section：独立的内容节块，一般包含标题和内容 article：一种特殊的section，定义文档中的具体的文章内容 nav：页面导航的链接组 aside：标签用来装载非正文的内容，此标签中的文字权重低 header：定义文档的页眉，不仅仅是文档的页头可以使用header，一个独立块的头部也应该使用header footer：定义section或document的页脚 我们应该根据内容的性质决定使用特定的标签 h1一定只能出现一个，不是HTML的约定，页面中最重要的内容 time标签专门用于时间， datetime应该是一个标准时间格式， pubdate指的是当前时间为article的发布时间 在H5中，主体结构标签默认和DIV都是相同的块级效果， 但是DIV没有语义，而以上标签有特定语义 2.2. 为什么要有语义化标签 能够便于开发者阅读和写出更优雅的代码，代码如诗 同时让浏览器或是网络爬虫可以很好地解析，从而更好分析其中的内容 使用语义化标签会具有更好地搜索引擎优化 切记 HTML的职责是描述一块内容是什么（或其意义） 而不是它长的什么样子，它的外观应该由CSS来决定。 3. 智能表单3.1. 新的表单类型 email - 限定输入内容为邮箱地址，表单提交时会校验格式 url - 限定输入内容为URL，表单提交时会校验格式 number - 限定输入内容为数字，表单提交时会校验格式 range - 数值范围选择器 Date Pickers - 日期时间选择器 样式不能修改，移动端用的比较多，因为移动端显示的是系统的时间或日期选择器 date - 选取日、月、年 month - 选取月、年 week - 选取周和年 time - 选取时间（小时和分钟） datetime - 选取时间、日、月、年，浏览器兼容性不好，效果等同于datetime-local datetime-local - 选取本地时间、日、月、年 search - 搜索域，语义化，表示定义搜索框 3.2. 新的表单属性 form 上使用的新属性 autocomplete 设置整个表单是否开启自动完成 on|off novalidate 设置H5的表单校验是否工作 true 不工作 不加该属性代表校验 input 上使用的新属性 autocomplete 单独设置每个文本框的自动完成 autofocus 设置当前文本域页面加载完了过后自动得到焦点 form 属性是让表单外的表单元素也可以跟随表单一起提交 form overrides formaction 在submit上重写表单的特定属性，当点击当前submit时会以当前值使用 formenctype, formmethod, formnovalidate, formtarget list 作用就是指定当前文本框的自动完成列表的数据 datalist 在界面上是看不见的，只是用于定义数据列表的 min / max / step min max 限制值的范围，但是不会再输入时限制，提交时校验， step设置的是每次加减的增量 主要使用在number range datepicker上 multiple 文本域的多选 pattern 设置文本框的匹配格式（正则） placeholder 文本框占位符 required 限制当前input为必须的 3.3. 虚拟键盘适配 在移动端中，我们可以通过不同的表单类型控制弹出的键盘类型 3.4. 关于什么时候使用H5的新特性，能不能使用新特性的问题 无伤大雅的地方直接用 比如一个文本框，加上placeholder就具备占位文本提示功能，浏览器不支持也不会报错，那就可以直接使用 再比如&lt;input type=&quot;email&quot;&gt;，如果浏览器不支持，默认会显示文本框，那也可以直接用。 4. 网页多媒体4.1. 音频 定义音频播放组件 1&lt;audio src="要播放的音频文件"&gt;&lt;/audio&gt; 4.2. 视频 定义播放视频组件 1&lt;video src="要播放的视频文件"&gt;&lt;/video&gt; 4.3. 旧版本浏览器提示 如果HTML中遇到不能识别的标签，就会将该标签当做DIV(块级元素) 那么video中的innerHTML也就会直接显示在界面上 利用这个特点我们可以实现不支持video标签的浏览器提示 1234&lt;video src="demo.mp4"&gt; &lt;!-- 如果浏览器不识别video标签，以下内容可以直接显示在浏览器上 --&gt; &lt;p&gt;抱歉，您的浏览器不支持视频播放！&lt;/p&gt;&lt;/video&gt; 4.4. 格式兼容 每个浏览器的音视频格式支持不同（版权问题） 需要兼容更多的浏览器，可以通过定义多个&lt;source&gt;的方式实现 html解析过程中会找其中第一个能认识的格式播放，一旦找到认识的视频格式，就不会再往后找了 1234567&lt;video controls width="500"&gt; &lt;!-- 分析第一个source格式是否支持，如果支持则加载该文件，不支持继续往下解析 --&gt; &lt;source src="chrome.mp4"&gt; &lt;source src="chrome.ogv"&gt; &lt;source src="chrome.webm"&gt; &lt;p&gt;抱歉，您的浏览器不支持视频播放！&lt;/p&gt;&lt;/video&gt; 因此不管是audio还是video都不要直接设置标签的src 4.5. 多媒体标签属性 属性 含义 controls 决定是否显示控制菜单 autoplay 自动播放 loop 循环播放 height/width 定义播放器的宽高，只会在视频标签中生效 preload 预加载 是否在页面加载完成并且没有开始播放时就开始加载文件，如果有自动播放属性则该属性无意义 4.6. 自定义播放器外观 隐藏原生的控制菜单，也就是删除标签中的controls属性 自己设计一套界面控制元素，比如播放按钮，音量控制开关之类 为每个不同的控制元素注册对应的事件 在事件中通过视频元素的API实现自定义播放器的效果 具体的多媒体元素API表： 4.6.1. 方法 方法 描述 addTextTrack() 向音频/视频添加新的文本轨道 canPlayType() 检测浏览器是否能播放指定的音频/视频类型 load() 重新加载音频/视频元素 play() 开始播放音频/视频 pause() 暂停当前播放的音频/视频 4.6.2. 属性 属性 描述 audioTracks 返回表示可用音轨的 AudioTrackList 对象 autoplay 设置或返回是否在加载完成后随即播放音频/视频 buffered 返回表示音频/视频已缓冲部分的 TimeRanges 对象 controller 返回表示音频/视频当前媒体控制器的 MediaController 对象 controls 设置或返回音频/视频是否显示控件（比如播放/暂停等） crossOrigin 设置或返回音频/视频的 CORS 设置 currentSrc 返回当前音频/视频的 URL currentTime 设置或返回音频/视频中的当前播放位置（以秒计） defaultMuted 设置或返回音频/视频默认是否静音 defaultPlaybackRate 设置或返回音频/视频的默认播放速度 duration 返回当前音频/视频的长度（以秒计） ended 返回音频/视频的播放是否已结束 error 返回表示音频/视频错误状态的 MediaError 对象 loop 设置或返回音频/视频是否应在结束时重新播放 mediaGroup 设置或返回音频/视频所属的组合（用于连接多个音频/视频元素） muted 设置或返回音频/视频是否静音 networkState 返回音频/视频的当前网络状态 paused 设置或返回音频/视频是否暂停 playbackRate 设置或返回音频/视频播放的速度 played 返回表示音频/视频已播放部分的 TimeRanges 对象 preload 设置或返回音频/视频是否应该在页面加载后进行加载 readyState 返回音频/视频当前的就绪状态 seekable 返回表示音频/视频可寻址部分的 TimeRanges 对象 seeking 返回用户是否正在音频/视频中进行查找 src 设置或返回音频/视频元素的当前来源 startDate 返回表示当前时间偏移的 Date 对象 textTracks 返回表示可用文本轨道的 TextTrackList 对象 videoTracks 返回表示可用视频轨道的 VideoTrackList 对象 volume 设置或返回音频/视频的音量 4.6.3. 事件 事件 描述 abort 当音频/视频的加载已放弃时 canplay 当浏览器可以播放音频/视频时 canplaythrough 当浏览器可在不因缓冲而停顿的情况下进行播放时 durationchange 当音频/视频的时长已更改时 emptied 当目前的播放列表为空时 ended 当目前的播放列表已结束时 error 当在音频/视频加载期间发生错误时 loadeddata 当浏览器已加载音频/视频的当前帧时 loadedmetadata 当浏览器已加载音频/视频的元数据时 loadstart 当浏览器开始查找音频/视频时 pause 当音频/视频已暂停时 play 当音频/视频已开始或不再暂停时 playing 当音频/视频在已因缓冲而暂停或停止后已就绪时 progress 当浏览器正在下载音频/视频时 ratechange 当音频/视频的播放速度已更改时 seeked 当用户已移动/跳跃到音频/视频中的新位置时 seeking 当用户开始移动/跳跃到音频/视频中的新位置时 stalled 当浏览器尝试获取媒体数据，但数据不可用时 suspend 当浏览器刻意不获取媒体数据时 timeupdate 当目前的播放位置已更改时 volumechange 当音量已更改时 waiting 当视频由于需要缓冲下一帧而停止 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 获取界面上的video元素，所有的操作必须通过它实现var video = document.getElementById('video');var btn_play = document.getElementById('btn_play');// 注册点击事件// addEventListener 用于注册事件， 将事件属性的on去掉 作为第一个参数传入btn_play.addEventListener('click', function() &#123; video.play(); btn_play.disabled = true; btn_pause.disabled = false;&#125;);var btn_pause = document.getElementById('btn_pause');btn_pause.addEventListener('click', function() &#123; video.pause(); btn_play.disabled = false; btn_pause.disabled = true;&#125;);var btn_muted = document.getElementById('btn_muted');btn_muted.addEventListener('click', function() &#123; // 交互变化true或false video.muted = !video.muted; btn_muted.innerHTML = video.muted ? "取消静音" : "静音";&#125;);var volume = document.getElementById('volume');volume.addEventListener('change', function(e) &#123; // 拿一下当前volume的值 video.volume = volume.value;&#125;);var btn_speed_up = document.getElementById('btn_speed_up');btn_speed_up.addEventListener('click', function(e) &#123; // 加速 video.playbackRate += 0.1;&#125;);var btn_speed_down = document.getElementById('btn_speed_down');btn_speed_down.addEventListener('click', function(e) &#123; // 减速 video.playbackRate -= 0.1;&#125;);var btn_forward = document.getElementById('btn_forward');btn_forward.addEventListener('click', function(e) &#123; // 前进5秒 video.currentTime += 5;&#125;);var btn_back = document.getElementById('btn_back');btn_back.addEventListener('click', function(e) &#123; // 后退5秒 video.currentTime -= 5;&#125;);// 注册视频播放状态变化事件video.addEventListener('timeupdate', function() &#123; // console.log(1111); progress.value = (video.currentTime / video.duration) * 100;&#125;); 4.7. 全屏 API HTML5中提供了可以通过JS实现网页全屏的效果 具体的方式就是通过特定元素的requestFullScreen方法实现 由于在不同浏览器中该方法需要加上特定前缀 退出全屏通过exitFullScreen方法 12345678910111213141516171819// 全屏function fullScreen(element) &#123; if (element.requestFullScreen) &#123; element.requestFullScreen(); &#125; else if (element.webkitRequestFullScreen) &#123; element.webkitRequestFullScreen() &#125; else if (element.mozRequestFullScreen) &#123; element.mozRequestFullScreen() &#125; else if (element.oRequestFullScreen) &#123; element.oRequestFullScreen() &#125; else if (element.msRequestFullScreen) &#123; element.msRequestFullScreen() &#125;&#125;var btnFullScreen = document.getElementById('btn_fullscreen');btnFullScreen.addEventListener('click', function() &#123; fullScreen(video); // fullScreen(document.body);&#125;); 解决问题的思路比如何实现一个需求更重要，因为你不可能每次都遇到相同的需求 4.8. SVG 了解* iframe的作用就是在网页中挖个坑，在这个坑里再展示一个页面 svg本身也是文档 所以可以使用iframe的方式载入 5. JS 基础 API5.1. 新选择器 JavaScript在HTML5中多了一套原生选择器API 其功能类似jQuery选择器 写法上类似原本的document.getElementById(‘xxx’) 123var element1 = document.getElementById('section1'); √ 已经getvar elements2 = document.getElementsByTagName('div'); √ 已经getvar elements3 = document.getElementsByClassName('section'); 除了这种简单的类名选择器，H5中新增了很多更高级的API： 123document.querySelectorAll('ul');document.querySelectorAll('.container');document.querySelector('div#container &gt; .inner'); API 描述 返回结果 querySelector 获取第一个满足选择器条件的元素 一个DOM对象 querySelectorAll 获取所有满足选择器条件的元素 包含多个DOM对象的数组 getElementsByClassName 获取所有使用指定类名的元素 包含多个DOM对象的数组 小提示：h5大部分时候就是将我们经常需要的操作原生支持一下，让我们使用起来更方便，不用再借助第三方的框架 5.2. Element.classList H5中DOM对象多了一个classList属性 该属性其实就是是一个数组 这个数组中的内容就是当前DOM元素的每一个类 具体的操作如下： API 描述 对比jQuery element.classList.add() 给当前元素添加指定类名 $element.addClass() element.classList.remove() 在当前元素中删除指定类名 $element.removeClass() element.classList.contains() 判断当前元素中是否存在指定类名 $element.hasClass() element.classList.toggleClass() 在当前元素上切换指定类名的存在 $element.toggleClass() 5.3. 自定义属性 DATA-* ! 在HTML5中，如果想要给元素添加一些自定义属性 可以DOM对象添加一些data-xxx的属性 HTML5中data-是自定义属性的前缀 一般用来记录与当前DOM强相关的数据 123&lt;ul id="users"&gt; &lt;li data-id="1" data-age="18" data-gender="true"&gt;张三&lt;/li&gt;&lt;/ul&gt; 如果需要用JS的方式操作自定义属性，可以通过getAttribute()/setAttribute()方式 当然HTML5在JavaScript中提供了一个新的 API：dataset， 用于操作元素的自定义属性 12345678var liElement = document.querySelector('#users &gt; li');// 添加一个自定义属性liElement.dataset['name'] = '张三';// 获取liElement中所有的自定义属性console.log(liElement.dataset);// output: &#123;id: 1, age: 18, gender: true, name: '张三'&#125; 6. 离线 &amp; 存储6.1. Application CacheApplication Cache 就是让网页可以离线访问的技术 使用方式： 创建一个缓存清单文件（比如：cache.manifest） 1234567891011CACHE MANIFEST# version 1.0.7CACHE: css/style.css js/script.js img/logo.png index.htmlNETWORK: * 回到HTML中，给HTML标签添加manifest属性，指向刚刚创建的缓存清单文件 123&lt;html manifest="cache.manifest"&gt;...&lt;/html&gt; JS中可以捕获到Application Cache的更新事件： 1234567891011if (window.applicationCache) &#123; window.applicationCache.addEventListener('updateready', function(e) &#123; // 更新完成触发 if (window.applicationCache.status == window.applicationCache.UPDATEREADY) &#123; window.applicationCache.swapCache(); if (confirm('更新成功，是否刷新页面?')) &#123; window.location.reload(); &#125; &#125; &#125;);&#125; 6.2. Web StorageHTML5中提供了可以离线操作的数据存储接口： localStorage （永久，除非用户手动清除） sessionStorage （会话，关闭浏览器清除） 两者操作方式完全相同，只不过是数据存储的周期不同 1234567891011var btnSet = document.querySelector('#btn_set');var btnGet = document.querySelector('#btn_get');var txtValue = document.querySelector('#txt_value');btnGet.addEventListener('click', function() &#123; // txtValue.value = localStorage.getItem('key1'); txtValue.value = localStorage['key1'];&#125;);btnSet.addEventListener('click', function() &#123; // localStorage.setItem('key1', txtValue.value); localStorage['key1'] = txtValue.value;&#125;); getItem方式获取一个不存在的键 返回空字符串 []方式获取一个不存在的键 返回undefined 7. 文件 API input file类型，文件类型的限制 7.1. 读取本地文件信息文件域对象可以获取用户选择文件的信息： 文件名 最近修改时间 文件大小 文件类型 123456var input = document.querySelector('#input_1');var file = input.files[0];file.name // 获取文件名file.lastModifiedDate // 获取最近修改时间file.size // 获取文件大小（单位KB）file.type // 获取文件类型（如：text/plain、image/png） 7.2. 文件域改变事件7.3. 文件域样式7.4. 使用FileReader读取文件内容FileReader就是用来读取本地文件的对象 123456789var reader = new FileReader();reader.addEventListener('load', function () &#123; this.result; // 读取出来的结果&#125;);reader.readAsText(file); // 以文本的形式读取reader.readAsDataURL(file); // 以DataURI的形式读取// 以下（后台工程师用，前端不会用到）reader.readAsBinaryString(file); // 二进制格式reader.readAsArrayBuffer(file); // 字节数组 8. 拖放操作8.1. 网页内元素拖放 拖放是 HTML5 中非常常见的功能 我们可以通过在元素上添加draggable=&quot;true&quot;属性实现元素允许被拖拽 提示：链接和图片默认是可拖动的，不需要 draggable 属性。 ondrag 事件在元素或者选取的文本被拖动时触发。 在拖放的过程中会触发以下事件： 在拖动目标上触发事件 (源元素): ondragstart - 用户开始拖动元素时触发 ondrag - 元素正在拖动时触发 ondragend - 用户完成元素拖动后触发 释放目标时触发的事件（目标元素）: ondragenter - 当被鼠标拖动的对象进入其容器范围内时触发此事件 ondragover - 当某被拖动的对象在另一对象容器范围内拖动时触发此事件 ondragleave - 当被鼠标拖动的对象离开其容器范围内时触发此事件 ondrop - 在一个拖动过程中，释放鼠标键时触发此事件 注意： 在拖动元素时，每隔 350 毫秒会触发 ondrag 事件。 8.2. 拖拽删除效果 作业 8.3. 桌面文件拖拽至网页12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 找到目标位置框框var target = document.querySelector('#target');var fileList = document.querySelector('#result');// 注册拖拽进入target.addEventListener('dragenter', function() &#123; this.classList.add('actived');&#125;);// 离开target.addEventListener('dragleave', function() &#123; this.classList.remove('actived');&#125;);// 如果想要捕获drop事件 就一定得在该事件中阻止默认事件target.addEventListener('dragover', function(e) &#123; e.preventDefault(); e.stopPropagation();&#125;);// 当元素放到该对象上target.addEventListener('drop', function(e) &#123; if (e.dataTransfer.files.length) &#123; var files = e.dataTransfer.files; for (var i = 0; i &lt; files.length; i++) &#123; var li = document.createElement('li'); li.setAttribute('class', 'list-group-item'); // 创建信息的子节点 li.innerHTML = '&lt;h5 class="list-group-item-heading"&gt;' + files[i].name + '&lt;/h5&gt;&lt;p class="list-group-item-text"&gt;' + files[i].lastModifiedDate.toLocaleDateString() + ' ' + files[i].lastModifiedDate.toLocaleTimeString() + ' ' + (files[i].size / 1024).toFixed(2) + 'KB&lt;/p&gt;'; fileList.appendChild(li); &#125; &#125; else &#123; // 短路运算 // var data = e.dataTransfer.getData('text/plain') || e.dataTransfer.getData('text/uri-list'); var data = e.dataTransfer.getData('text/plain'); if (data) &#123; // 拖入的是文本 target.innerHTML = data; &#125; else &#123; var img = document.createElement('img'); img.src = e.dataTransfer.getData('text/uri-list'); target.appendChild(img); &#125; &#125; this.classList.remove('actived'); e.preventDefault(); e.stopPropagation();&#125;);]]></content>
  </entry>
  <entry>
    <title><![CDATA[Bower常用命令]]></title>
    <url>%2Fblog%2F2016%2F11%2F03%2Fbower-md%2F</url>
    <content type="text"><![CDATA[12345678910111213141516$ # 初始化一个Bower的配置文件$ bower init$ # 安装一个包$ bower install bootstrap$ # GitHub shorthand$ bower install desandro/masonry$ # Git endpoint$ bower install git://github.com/user/package.git$ # URL$ bower install http://example.com/script.js$ # 安装一个包并将其添加到配置文件$ bower install bootstrap --save$ # 卸载一个包$ bower uninstall bootstrap$ # 更新所有的包$ bower update Bower配置文件 项目根目录 用户主目录]]></content>
  </entry>
  <entry>
    <title><![CDATA[git 基本命令]]></title>
    <url>%2Fblog%2F2016%2F11%2F03%2Fgit-md%2F</url>
    <content type="text"><![CDATA[5.3.1.初始化一个本地GIT仓储1234// 定位到仓储文件夹目录$ cd /dir// 初始化本地仓储$ git init 5.3.2.添加本地GIT忽略清单文件.gitignore12// 添加OS X中系统文件.DS_Store到忽略清单，这将忽略项目任意目录下的.DS_Store文件或是文件夹$ echo .DS_Store &gt;&gt; .gitignore 5.3.3.查看本地仓储的变更状态1$ git status 5.3.4.添加本地暂存（托管）文件123456// 添加指定文件名的文件$ git add README.md// 添加通配符匹配的文件$ git add *.md// 添加所有未托管的文件（忽略.gitignore清单中的列表）$ git add --all 5.3.5.提交被托管的文件变化到本地仓储1$ git commit -m &apos;Initial commit(change log)&apos; 5.3.6.为仓储添加远端（服务器端）地址1234// 添加一个远端地址并起了一个别名叫origin$ git remote add origin https://github.com/Micua/Git.git// 查看现有的远端列表$ git remote -v 5.3.7.将本地仓储的提交记录推送到远端的master分支1$ git push -u origin master 5.3.8.拉取远端master分支的更新记录到本地1$ git pull origin master]]></content>
  </entry>
  <entry>
    <title><![CDATA[Gulp入门]]></title>
    <url>%2Fblog%2F2016%2F10%2F25%2Fglup-first%2F</url>
    <content type="text"><![CDATA[当下的前端开发 不再是简简单单的使用HTML+CSS+JavaScript这些简单的技术构建网页应用程序了 我们要提高效率，就必须减少重复的工作 使用less之类预处理的CSS coffeescript 提供开发阶段的便利，开发阶段更快捷 现在的开发行业优质的开发人员是不应该将精力放在这些重复性质的工作上 Gulp就是一种可以自动化完成我们开发过程中大量的重复工作 预处理语言的编译 js css html 压缩混淆 图片体积优化 除gulp之外还有一些类似的自动化工具，比如grunt what how why Gulp简介 当下最流行的自动化工具 什么是自动化构建工具？ 自动完成一系列重复的操作 less → css coffeescript → js css压缩 js混淆 html压缩 img尺寸优化 。。。。 链接： 官网 中文网 gulp的包既包含工具，也包含一些编程的API 准备工作 安装Node.js Node.js 给前端带来了一场工业革命 http://npm.taobao.org/ 安装完成过后可以通过命令行工具node -v 安装nodejs过程会自动安装npm(node packages manager) npm 3 以前的版本文件依赖是层级依赖 npm 3 以后依赖关系改为平行依赖（windows上路径过长问题） gulp本身是node的模块 安装 gulp 命令行工具 npm install -g gulp -g 指的是在全局作用域中安装 测试命令 gulp -v 初始化 gulp 项目 在本地安装gulp包 npm install gulp –save 创建任务 - gulpfile.js gulpfile.js 就是gulp的主文件 基本使用 定义一个任务 复制单个文件 复制多个文件 globs匹配语法 src/* src/*/* src/**/* src/*.jpg src/*.{jpg,png} 多个globs [‘src/*.{jpg,png}’,’a/a.html’] 排除某些文件 !xxxxx 默认任务 gulp 中的任务名有个特殊值 default 文件监视自动执行任务 常用插件 编译 Less：gulp-less 编译 Jade: gulp-jade 创建本地服务器：gulp-connect 合并文件：gulp-concat 最小化 js 文件：gulp-uglify 重命名文件：gulp-rename 最小化 css 文件：gulp-minify-css 压缩html文件 gulp-minify-html 最小化图像：gulp-imagemin]]></content>
  </entry>
  <entry>
    <title><![CDATA[gulp demo]]></title>
    <url>%2Fblog%2F2016%2F10%2F25%2Fglup-demo%2F</url>
    <content type="text"><![CDATA[//1. LESS编译 压缩 合并 //2. JS合并 压缩 混淆 //3. img复制 //4. html压缩 ‘use strict’;// 在gulpfile中先载入gulp包，因为这个包提供了一些APIvar gulp = require(‘gulp’);var less = require(‘gulp-less’);var cssnano = require(‘gulp-cssnano’); // 1. LESS编译 压缩 –合并没有必要，一般预处理CSS都可以导包gulp.task(‘style’, function() { // 这里是在执行style任务时自动执行的 gulp.src([‘src/styles/.less’, ‘!src/styles/_.less’]) .pipe(less()) .pipe(cssnano()) .pipe(gulp.dest(‘dist/styles’)) .pipe(browserSync.reload({ stream: true }));}); var concat = require(‘gulp-concat’);var uglify = require(‘gulp-uglify’); // 2. JS合并 压缩混淆gulp.task(‘script’, function() { gulp.src(‘src/scripts/*.js’) .pipe(concat(‘all.js’)) .pipe(uglify()) .pipe(gulp.dest(‘dist/scripts’)) .pipe(browserSync.reload({ stream: true }));}); // 3. 图片复制gulp.task(‘image’, function() { gulp.src(‘src/images/.‘) .pipe(gulp.dest(‘dist/images’)) .pipe(browserSync.reload({ stream: true }));}); var htmlmin = require(‘gulp-htmlmin’);// 4. HTMLgulp.task(‘html’, function() { gulp.src(‘src/*.html’) .pipe(htmlmin({ collapseWhitespace: true, removeComments: true })) .pipe(gulp.dest(‘dist’)) .pipe(browserSync.reload({ stream: true }));}); var browserSync = require(‘browser-sync’);gulp.task(‘serve’, function() { browserSync({ server: { baseDir: [‘dist’] }, }, function(err, bs) { console.log(bs.options.getIn([“urls”, “local”])); }); gulp.watch(‘src/styles/.less’,[‘style’]); gulp.watch(‘src/scripts/.js’,[‘script’]); gulp.watch(‘src/images/.‘,[‘image’]); gulp.watch(‘src/*.html’,[‘html’]);});]]></content>
  </entry>
  <entry>
    <title><![CDATA[bootstrap微金所项目实战]]></title>
    <url>%2Fblog%2F2016%2F10%2F25%2Fbootstrap-second%2F</url>
    <content type="text"><![CDATA[微金所项目实战1. 搭建Bootstrap页面骨架及项目目录结构12345678├─ /weijinsuo/ ··················· 项目所在目录└─┬─ /css/ ······················· 我们自己的CSS文件 ├─ /font/ ······················ 使用到的字体文件 ├─ /img/ ······················· 使用到的图片文件 ├─ /js/ ························ 自己写的JS脚步 ├─ /lib/ ······················· 从第三方下载回来的库【只用不改】 ├─ /favicon.ico ················ 站点图标 └─ /index.html ················· 入口文件 1.1.约定编码规范1.1.1.HTML约定 在head中引入必要的CSS文件，优先引用第三方的CSS，方便我们自己的样式覆盖 在body末尾引入必要的JS文件，优先引用第三方的JS，注意JS文件之间的依赖关系，比如bootstrap.js依赖jQuery，那就应该先引用jquery.js 然后引用bootstrap.js 1.1.2.CSS约定 除了公共级别样式，其余样式全部由 模块前缀 尽量使用 直接子代选择器， 少用间接子代 避免错杀 1.2.HTML5文档结构12345678910&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;页面标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 1.3.Viewport设置1&lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0"&gt; html中插入视口设置，可以通过emmet meta:vp 插入 1.4.浏览器兼容模式1&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; html中插入兼容模式设置，可以通过emmet meta:compat 插入 1.5.favicon（站点图标）1&lt;link rel="shortcut icon" type="image/x-icon" href="favicon.ico"&gt; html中插入图标链接，可以通过emmet link:favicon 插入 1.6.引入相应的第三方文件123456&lt;link rel="stylesheet" href="bootstrap.css"&gt;&lt;link rel="stylesheet" href="my.css"&gt;...&lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;script src="bootstrap.js"&gt;&lt;/script&gt;&lt;script src="my.js"&gt;&lt;/script&gt; 1.7.在我们默认的样式表中将默认字体设置为：12345678body&#123; font-family: "Helvetica Neue", Helvetica, Microsoft Yahei, Hiragino Sans GB, WenQuanYi Micro Hei, sans-serif;&#125; 2.完成页面空结构 先划分好页面中的大容器，然后在具体看每一个容器中单独的情况 1234567891011121314151617181920212223242526&lt;body&gt; &lt;!-- 头部区域 --&gt; &lt;header&gt;&lt;/header&gt; &lt;!-- /头部区域 --&gt; &lt;!-- 广告轮播 --&gt; &lt;section&gt;&lt;/section&gt; &lt;!-- /广告轮播 --&gt; &lt;!-- 特色介绍 --&gt; &lt;section&gt;&lt;/section&gt; &lt;!-- /特色介绍 --&gt; &lt;!-- 立即预约 --&gt; &lt;section&gt;&lt;/section&gt; &lt;!-- /立即预约 --&gt; &lt;!-- 产品推荐 --&gt; &lt;section&gt;&lt;/section&gt; &lt;!-- /产品推荐 --&gt; &lt;!-- 新闻列表 --&gt; &lt;section&gt;&lt;/section&gt; &lt;!-- /新闻列表 --&gt; &lt;!-- 合作伙伴 --&gt; &lt;section&gt;&lt;/section&gt; &lt;!-- /合作伙伴 --&gt; &lt;!-- 脚注区域 --&gt; &lt;footer&gt;&lt;/footer&gt; &lt;!-- /脚注区域 --&gt;&lt;/body&gt; 3.构建顶部通栏123&lt;header&gt; &lt;div class="topbar"&gt;&lt;/div&gt;&lt;/header&gt; 3.1.container类 用于定义一个固定宽度且居中的版心 12345678&lt;div class="topbar"&gt; &lt;div class="container"&gt; &lt;!-- 此处的代码会显示在一个固定宽度且居中的容器中 该容器的宽度会跟随屏幕的变化而变化 --&gt; &lt;/div&gt;&lt;/div&gt; 3.2.栅格系统 Bootstrap中定义了一套响应式的网格系统， 其使用方式就是将一个容器划分成12列， 然后通过col-xx-xx的类名控制每一列的占比 3.2.1.row类 因为每一个列默认有一个15px的左右外边距 row类的一个作用就是通过左右-15px屏蔽掉这个边距 123&lt;div class="container"&gt; &lt;div class="row"&gt;&lt;/div&gt;&lt;/div&gt; 3.2.2.col-\-*类 col-xs-[列数]：在超小屏幕下展示几份 col-sm-[列数]：在小屏幕下展示几份 col-md-[列数]：在中等屏幕下展示几份 col-lg-[列数]：在大屏幕下展示几份 xs : 超小屏幕 手机 (&lt;768px) sm : 小屏幕 平板 (≥768px) md : 中等屏幕 桌面显示器 (≥992px) lg : 大屏幕 大桌面显示器 (≥1200px) 123456&lt;div class="row"&gt; &lt;div class="col-md-2 text-center"&gt;&lt;/div&gt; &lt;div class="col-md-5 text-center"&gt;&lt;/div&gt; &lt;div class="col-md-2 text-center"&gt;&lt;/div&gt; &lt;div class="col-md-3 text-center"&gt;&lt;/div&gt;&lt;/div&gt; 此处顶部通栏已经被划分成四列text-center的作用就是让内部内容居中显示 3.2.字体图标12345678910111213141516@font-face &#123; font-family: 'itcast'; src: url('../font/MiFie-Web-Font.eot') format('embedded-opentype'), url('../font/MiFie-Web-Font.svg') format('svg'), url('../font/MiFie-Web-Font.ttf') format('truetype'), url('../font/MiFie-Web-Font.woff') format('woff');&#125;[class^="icon-"],[class*=" icon-"] &#123; /*注意上面选择器中间的空格*/ /*我们使用的名为itcast的字体就是上面的@font-face的方式声明的*/ font-family: itcast; font-style: normal;&#125;.icon-mobilephone::before&#123; content: '\e908';&#125; 123456789&lt;div class="col-md-2 text-center"&gt; &lt;a class="mobile-link" href="#"&gt; &lt;i class="icon-mobile"&gt;&lt;/i&gt; &lt;span&gt;手机微金所&lt;/span&gt; &lt;!-- 这里使用的是bootstrap中的字体图标 --&gt; &lt;i class="glyphicon glyphicon-chevron-down"&gt;&lt;/i&gt; &lt;img src="..." alt=""&gt; &lt;/a&gt;&lt;/div&gt; 字体文件格式 eot : embedded-opentype svg : svg ttf : truetype woff : woff 3.4.hover图片展示123.mobile-link:hover &gt; img &#123; display: block;&#125; 3.5.按钮样式生成 http://blog.koalite.com/bbg/ 可以通过界面生成一个新的按钮样式 123456789101112131415161718192021222324252627282930313233343536373839404142434445.btn-itcast &#123; color: #ffffff; background-color: #E92322; border-color: #DB3B43;&#125;.btn-itcast:hover,.btn-itcast:focus,.btn-itcast:active,.btn-itcast.active,.open .dropdown-toggle.btn-itcast &#123; color: #ffffff; background-color: #E92322; border-color: #DB3B43;&#125;.btn-itcast:active,.btn-itcast.active,.open .dropdown-toggle.btn-itcast &#123; background-image: none;&#125;.btn-itcast.disabled,.btn-itcast[disabled],fieldset[disabled] .btn-itcast,.btn-itcast.disabled:hover,.btn-itcast[disabled]:hover,fieldset[disabled] .btn-itcast:hover,.btn-itcast.disabled:focus,.btn-itcast[disabled]:focus,fieldset[disabled] .btn-itcast:focus,.btn-itcast.disabled:active,.btn-itcast[disabled]:active,fieldset[disabled] .btn-itcast:active,.btn-itcast.disabled.active,.btn-itcast[disabled].active,fieldset[disabled] .btn-itcast.active &#123; background-color: #E92322; border-color: #DB3B43;&#125;.btn-itcast .badge &#123; color: #E92322; background-color: #ffffff;&#125; 3.5小屏幕隐藏1&lt;div class="topbar hidden-xs hidden-sm"&gt;&lt;/div&gt; 或者 1&lt;div class="topbar visible-md visible-lg"&gt;&lt;/div&gt; hidden-xx : 在某种屏幕下隐藏 visible-xx : 在某种屏幕尺寸下显示 visible-xx-xx：最后一个xx是决定显示时的display到底是啥 4.导航通栏 在使用了boostrap过后，大多数界面元素都是通过bootstrap提供好的界面组件修改得来 1234567891011121314151617181920212223242526272829&lt;nav class="navbar navbar-itcast navbar-static-top"&gt; &lt;div class="container"&gt; &lt;div class="navbar-header"&gt; &lt;button id="btn" type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#nav_list" aria-expanded="false"&gt; &lt;span class="sr-only"&gt;切换菜单&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class="navbar-brand" href="#"&gt; &lt;i class="icon-icon"&gt;&lt;/i&gt; &lt;i class="icon-logo"&gt;&lt;/i&gt; &lt;/a&gt; &lt;/div&gt; &lt;div id="nav_list" class="collapse navbar-collapse"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;我要投资&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;我要借款&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;平台介绍&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;新手专区&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;最新动态&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;微论坛&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class="nav navbar-nav navbar-right hidden-sm"&gt; &lt;li&gt;&lt;a href="#"&gt;个人中心&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/nav&gt; 4.1.Bootstrap扩展 通过bootstrap文档对导航条样式的设置发现，其实本身是有一个类似于主题的概念 navbar-default：默认的外观 navbar-inverse：暗色背景的样式 所以我们希望可以通过自定义一套完整的风格： navbar-itcast 1234.navbar-itcast&#123; ...&#125;...具体代码参考navbar-default实现即可 4.2.品牌logo 任然使用字体图标 4.3.菜单行高调整 默认样式中菜单的行高为20px，我们可以调整为自己想要的高度 一般都是通过自己的样式去覆盖 5.轮播图5.1.Bootstrap JS插件使用 在一个较小屏幕下展示一个超宽的图片，想让图片居中显示 背景图 p-a l 50% m-l -width/2 5.2.background使用5.2.1.background-size length 如100px 100px percentage 如90% 90% cover 背景图片的较小边放大到目标大小结束 contain 相反 5.3.图片响应式 目的 各种终端都需要正常显示图片 移动端应该使用更小（体积）的图片 实现方式 5.4.window resize事件6.网站特性6.1.网格系统6.2.媒体对象样式6.3.响应式辅助类型- hidden-xx 7.预约投标7.1.pull-left7.2.pull-right8.投资产品8.1.Tab选项卡8.2.网格系统8.3.::before8.4.::after8.5.tooltip插件9.新闻资讯9.1.Tab选项卡9.2.响应式偏移10.合作伙伴10.1.相邻兄弟选择器11.登录对话框11.1模态框11.2表单样式12.导航吸顶12.1affix组件13.深度自定义13.1.http://v3.bootcss.com/customize13.2通过 Less 文件修改14.version 4http://www.cnblogs.com/micua/p/bootstrap-version4-alpha.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[Bootstrap入门]]></title>
    <url>%2Fblog%2F2016%2F10%2F25%2Fbootstrap-first%2F</url>
    <content type="text"><![CDATA[简介什么是Bootstrap？ 框架：库 lib library jQuery作为一个框架来讲，提供一套比较便捷的操作DOM的方式 把大家都需要的功能预先写好到一些文件 这就是一个框架 Bootstrap 让我们的 Web 开发更简单，更快捷； 注意是 Bootstrap 不是 BootStrap！这是一个词，不是合成词，其含义为：n. 引导指令,引导程序 Bootstrap 是当下最流行的前端框架（界面工具集）； 特点就是灵活简洁，代码优雅，美观大方； 其目的是为了让 Web 开发更敏捷； 是 Twitter 公司的两名前端工程师 Mark Otto 和 Jacob Thornton 在 2011 - 年发起的，并利用业余时间完成第一个版本的开发； 为什么使用Bootstarp？ 生态圈火，不断地更新迭代； 提供一套美观大方地界面组件； 提供一套优雅的 HTML+CSS 编码规范； 让我们的 Web 开发更简单，更快捷； 注意： 使用 Bootstrap 并不代表不用写 CSS 样式，而是不用写绝大多数大家都会用到的样式 准备下载Bootstrap https://github.com/twbs/bootstrap/releases/download/v3.3.6/bootstrap-3.3.6-dist.zip https://github.com/twbs/bootstrap/releases/download/v4.0.0-alpha.2/bootstrap-4.0.0-alpha.2-dist.zip 安装Bootstrap1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;页面标题&lt;/title&gt; &lt;!-- 引入Bootstrap核心样式文件（必须） --&gt; &lt;link rel="stylesheet" href="css/bootstrap.min.css"&gt; &lt;!-- 引入Bootstrap默认主题样式（可选） --&gt; &lt;link rel="stylesheet" href="css/bootstrap.theme.min.css"&gt; &lt;!-- 你自己的样式或其他文件 --&gt; &lt;link rel="stylesheet" href="example.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 你的HTML结构...... --&gt; &lt;!-- 以下代码，如果不使用JS插件则不需要 --&gt; &lt;!-- 由于Bootstrap的JS插件依赖jQuery，so 引入jQuery --&gt; &lt;script src="js/jquery.min.js"&gt;&lt;/script&gt; &lt;!-- 引入所有的Bootstrap的JS插件 --&gt; &lt;script src="bootstrap.min.js"&gt;&lt;/script&gt; &lt;!-- 你自己的脚本文件 --&gt; &lt;script src="example.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Bootstrap文档 官方文档 中文文档 基础的Bootstrap模板1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags --&gt; &lt;title&gt;Bootstrap 101 Template&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;link href="css/bootstrap.min.css" rel="stylesheet"&gt; &lt;!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries --&gt; &lt;!-- WARNING: Respond.js doesn't work if you view the page via file:// --&gt; &lt;!--[if lt IE 9]&gt; &lt;script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"&gt;&lt;/script&gt; &lt;script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;!-- jQuery (necessary for Bootstrap's JavaScript plugins) --&gt; &lt;script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"&gt;&lt;/script&gt; &lt;!-- Include all compiled plugins (below), or include individual files as needed --&gt; &lt;script src="js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Compatible1&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; 此属性为文档兼容模式声明，表示如果在IE浏览器下则使用最新的标准渲染当前文档 视口1&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; 视口的作用：在移动浏览器中，当页面宽度超出设备，浏览器内部虚拟的一个页面容器，将页面容器缩放到设备这么大，然后展示 目前大多数手机浏览器的视口（承载页面的容器）宽度都是980； 视口的宽度可以通过meta标签设置 此属性为移动端页面视口设置，当前值表示在移动端页面的宽度为设备的宽度，并且不缩放（缩放级别为1） width:视口的宽度 initial-scale：初始化缩放 user-scalable:是否允许用户自行缩放（值：yes/no; 1/0） minimum-scale:最小缩放，一般设置了用户不允许缩放，就没必要设置最小和最大缩放 maximum-scale:最大缩放 条件注释 条件注释的作用就是当判断条件满足时，就会执行注释中的HTML代码，不满足时会当做注释忽略掉 第三方依赖 jQuery Bootstrap框架中的所有JS组件都依赖于jQuery实现 html5shiv 让低版本浏览器可以识别HTML5的新标签，如header、footer、section等 respond 让低版本浏览器可以支持CSS媒体查询功能 建议以后在HTML中将脚步的引入放到页面最底下mediaquery12345678910@media (判断条件（针对于当前窗口的判断）)&#123; /*这里的代码只有当判断条件满足时才会执行*/&#125;@media (min-width: 768px) and (max-width: 992px) &#123; /*这里的代码只有当(min-width: 1280px)满足时才会执行*/ .container &#123; width: 750px; &#125;&#125; 当使用min-width作为判断条件一定要从小到大，其原因是CSS从上往下执行 基础CSS样式 概要 + 预置排版样式 统一预制标签样式 按钮样式 + 表格样式 + 表单样式 + 图片样式 + 辅助工具类 + 代码样式 + 栅格系统 xs : 超小屏幕 手机 (&lt;768px) sm : 小屏幕 平板 (≥768px) md : 中等屏幕 桌面显示器 (≥992px) lg : 大屏幕 大桌面显示器 (≥1200px) 响应式工具类 hidden-xx : 在某种屏幕下隐藏 visible-xx : 在某种屏幕尺寸下显示 预置界面组件 导航 导航条 面包屑导航 下拉菜单 按钮式下拉菜单 按钮组 输入框组 警告框 页头 分页 列表组 面板 媒体对象 进度条 Glyphicons 标签 徽章 缩略图 大屏幕 嵌入内容 内嵌 JavaScript插件JavaScript插件的依赖情况如何使用Javascript插件内置组件 模态对话框 下拉菜单 滚动监听 标签页 工具提示 弹出框 警告框 按钮 折叠面板 轮播图 吸顶效果 data-spy=”affix” data-offset-top=”什么位置出现” data-offset-bottom=”什么位置消失” 深度自定义 Bootstrap在线自定义 官网在线 中文网在线 源码编译LESS语言 官方文档 中文文档]]></content>
  </entry>
  <entry>
    <title><![CDATA[流行框架第三天：Angular入门]]></title>
    <url>%2Fblog%2F2016%2F10%2F25%2Fnode-first%2F</url>
    <content type="text"><![CDATA[Node服务器端开发第一天 Node简介及配置、快速上手、核心特点、模块化 Node简介客户端的JavaScript是怎样的 什么是 JavaScript？ 脚本语言 运行在浏览器中 一般用来做客户端页面的交互（Interactive） JavaScript 的运行环境？ 是不是运行在浏览器呢？ 不够严谨 运行在浏览器内核中的 JS 引擎（engine） 浏览器中的 JavaScript 可以做什么？ 操作DOM（对DOM的增删改、注册事件） AJAX/跨域 BOM（页面跳转、历史记录、console.log()、alert()） ECMAScript 浏览器中的 JavaScript 不可以做什么？ 文件操作（文件和文件夹的CRUD） 没有办法操作系统信息 由于运行环境特殊（我们写的代码是在不认识的人的浏览器中运行） 在开发人员能力相同的情况下编程语言的能力取决于什么？ -语言本身？- 语言本身只是提供定义变量，定义函数，定义类型，流程控制，循环结构之类的操作 取决于运行该语言的平台（环境） 对于JS来说，我们常说的JS实际是ES，大部分能力都是由浏览器的执行引擎决定 BOM和DOM可以说是浏览器开放出来的接口 比如：Cordova中提供JS调用摄像头，操作本地文件的API Java既是语言也是平台 Java运行在Java虚拟机（跨操作系统） PHP既是语言也是平台（跨操作系统） C#语言平台：.NET Framework（Windows） C#可以运行在MONO这样的平台 因为有人需要将C#运行在Linux平台，所有出现了MONO JavaScript 只可以运行在浏览器中吗？ 不是 能运行在哪取决于，这个环境有没有特定平台 什么是Node Node 就是 JavaScript 语言在服务器端的运行环境 所谓“运行环境（平台）”有两层意思： 首先，JavaScript 语言通过 Node 在服务器运行，在这个意义上，Node 有点像 JavaScript 虚拟机； 其次，Node 提供大量工具库，使得 JavaScript 语言与操作系统互动（比如读写文件、新建子进程），在这个意义上， Node 又是 JavaScript 的工具库。 为什么是JavaScriptNode的实现结构Node在当下Web开发领域的应用哪些公司在用重点理解 Node是一个JavaScript的运行环境（平台），不是一门语言，也不是JavaScript的框架； Node的实现结构； Node可以用来开发服务端应用程序，Web系统； 基于Node的前端工具集 环境配置安装包的方式安装 安装包下载链接： Mac OSX： darwin Windows： x64 x86 安装操作： 一路Next 更新版本 操作方式： 重新下载最新的安装包； 覆盖安装即可； 问题： 以前版本安装的很多全局的工具包需要重新安装 无法回滚到之前的版本 无法在多个版本之间切换（很多时候我们要使用特定版本） NVM工具的使用 Node Version Manager（Node版本管理工具） 由于以后的开发工作可能会在多个Node版本中测试，而且Node的版本也比较多，所以需要这么款工具来管理 安装操作步骤 下载：nvm-windows 解压到一个全英文路径 编辑解压目录下的settings.txt文件（不存在则新建） root 配置为当前 nvm.exe 所在目录 path 配置为 node 快捷方式所在的目录 arch 配置为当前操作系统的位数（32/64） proxy 不用配置 配置环境变量 可以通过 window+r : sysdm.cpl NVM_HOME = 当前 nvm.exe 所在目录 NVM_SYMLINK = node 快捷方式所在的目录 PATH += %NVM_HOME%;%NVM_SYMLINK%; 打开CMD通过set [name]命令查看环境变量是否配置成功 PowerShell中是通过dir env:[name]命令 NVM使用说明： https://github.com/coreybutler/nvm-windows/ NPM的目录之后使用再配置 配置Python环境 Node中有些第三方的包是以C/C++源码的方式发布的，需要安装后编译确保全局环境中可以使用python命令 环境变量的概念 环境变量就是操作系统提供的系统级别用于存储变量的地方 Windows中环境变量分为系统变量和用户变量 环境变量的变量名是不区分大小写的 特殊值： PATH 变量：只要添加到 PATH 变量中的路径，都可以在任何目录下搜索 Windows下常用的命令行操作 切换当前目录（change directory）：cd 创建目录（make directory）：mkdir 查看当前目录列表（directory）：dir 别名：ls（list） 清空当前控制台：cls 别名：clear 删除文件：del 别名：rm 注意：所有别名必须在新版本的 PowerShell 中使用 快速上手 事件驱动和非阻塞 模块化开发]]></content>
  </entry>
  <entry>
    <title><![CDATA[流行框架第三天：Angular入门]]></title>
    <url>%2Fblog%2F2016%2F10%2F24%2Fangular-first%2F</url>
    <content type="text"><![CDATA[推荐工具 在线编辑器 http://codepen.io/ https://jsfiddle.net/ Angular 简介什么是 AngularJS 一款非常优秀的前端高级 JS 框架 最早由 Misko Hevery 等人创建 2009 年被 Google 公式收购，用于其多款产品 目前有一个全职的开发团队继续开发和维护这个库 有了这一类框架就可以轻松构建 SPA 应用程序 轻松构建 SPA（单一页面应用程序） 单一页面应用程序： 只有一个页面（整个应用的一个载体） 内容全部是由AJAX方式呈现出啦的 其核心就是通过指令扩展了 HTML，通过表达式绑定数据到 HTML。 为什么使用 AngularJS 更少的代码，实现更强劲的功能 将一些以前在后台开发中使用的思想带入前端开发 带领当前市面上的框架走向模式化或者架构化 AngularJS 的核心特性 MVC 模块化 自动化双向数据绑定 指令系统 相关链接 http://www.apjs.net/ http://www.angularjs.cn/ http://docs.angularjs.cn/api https://material.angularjs.org http://angular-ui.github.io/ Angular 上手安装 Angular 下载 Angular.js 的包 https://github.com/angular/angular.js/releases 使用 CDN 上的 Angular.js http://apps.bdimg.com/libs/angular.js/1.4.9/angular.min.js 使用 Bower 安装 1bower install angular 使用 NPM 安装 1npm install angular 每种方式安装包，本质都是将angular的库下载到当前文件夹中 简单示例12 angular中最重要的概念是指令（directive） ng-model 是双向数据绑定的指令，效果就是将当前元素的value属性和模型中的user.name建立绑定关系 JS: BOM DOM ES 分析 Angular 示例使用总结运行官方文档CDN的优势Content Dev 快 节省自己服务器的带宽压力和流量 Angular 基础概念MVC 思想什么是 MVC 思想 将应用程序的组成划分为三个部分：Model View Controller 控制器的作用就是初始化模型用的； 模型就是用于存储数据的 视图用于展现数据 登陆案例 模型 我们数据库中所有用户的信息 接受控制器传来的用户名和密码进行校验的业务逻辑并返回true/false 控制器 接受用户在界面上填写的用户名和密码 将用户名和密码交给模型 视图 给用户呈现一个表单 接受用户输入内容，并将其提交给控制器 根据控制器返回的数据，响应用户页面 模块（Module） 划分应用程序结构 我们可以通过angular.module创建一个模块 angular.module方法传递两个参数才是创建模块，一个参数是获取模块 控制器（Controller） 通过$scope和视图关联 视图模型（$scope）表达式（Expression）单向数据绑定双向数据绑定Angular 指令系统]]></content>
  </entry>
  <entry>
    <title><![CDATA[流行框架第二天：Git与Angular入门]]></title>
    <url>%2Fblog%2F2016%2F10%2F24%2Fgit-second%2F</url>
    <content type="text"><![CDATA[复习 Node Node.js — 类似一个操作系统 一个JS的运行环境 主要用于开发Web应用程序（回想登陆的例子） 很多的前端开发工具都是基于node这个平台 所用的工具就相当于一些软件 NVM （可选的） Node Version Manager(Node的版本管理工具) 因为node的版本比较多，很多时候我们可能依赖多个版本，并要求自由切换 使用 nvm use [对应的版本号] [平台架构（如果是32系统需要写32,64位不用管）] nvm install [arch] 安装 nvm uninstall 卸载 nvm list 查看已经安装版本 官网 https://github.com/coreybutler/nvm-windows NPM node package manager(node的包管理工具) npm管理包非常方便，我们只需要记住使用哪个包就可以了 使用 npm install xxx 安装一个包到项目本地，必须要联网 安装完成过后项目根目录下会多一个node_modules文件夹，所有的下载下来的包全部在里面 由于需要记录项目依赖哪些东西，所以需要一个配置文件“package.json”，可以通过npm init命令生成 以后安装包的时候将其–save –save就是将我们安装的包名字和包版本记录到配置文件中的dependencies节点中 –save-dev 项目依赖分两种，一个就是普通的项目依赖比如bootstrap，还用一种只是开发阶段需要用的，这种属于开发依赖比如gulp，开发依赖最终记录在devDependencies节点里面 npm uninstall xxx –save npm install xxx -g(全局安装包) 如果你安装的是一个工具，工具要在每一个地方都能用，这种情况下一般全局安装。 Bower Web sites are made of lots of things ― frameworks, libraries, assets, and utilities. Bower manages all these things for you. Bower就是用来管理项目中所有的依赖，主要用于Web页面开发时使用的包管理，比如jquery，bootstrap 重复的轮子太多，抓住轮子与轮子之间的共性 Gulp FIS3 http://www.ydcss.com/archives/94 msi - microsoft installer 微软安装器 GIT什么是GIT 是一个源代码管理工具 在一个项目中，凡是由开发人员编写的都算是源代码 源代码有必要管理起来？ 让源代码可以被追溯，主要记录每次变更了什么，谁主导这次变化 人为的维护比较麻烦， GIT是Linux之父当年为了维护管理Linux的源代码写的一个工具 Git 之前 很多使用 svn vss tfs hs …… https://guides.github.com/ 安装GIT git命令行工具 基于git命令行的一个客户端软件（提供一个界面去管理源代码） GIT命令操作 初始化一个本地GIT仓储 12cd 当前项目目录git init // 初始化一个本地的仓库 就是在本地文件夹中添加了一个.git的文件夹用于记录所有的项目变更信息 查看本地仓储的变更状态 git status用于查看本地仓储的状态第一次查看，显示的是一坨没有被跟踪的文件 git status -s // -s 是输出简要的变更日志 添加本地暂存（托管）文件 git add可以将一个没有被跟踪的文件添加到跟踪列表 类似于node_modules这种性质的文件是不应该被跟踪 添加本地GIT忽略清单文件 在代码库文件夹的根目录添加一个.gitignore文件此文件用于说明忽略的文件有哪些 提交被托管的文件变化到本地仓储 git commit将本地的变化提交的本地的仓库文件夹归档一般在有了一个小单元的整体变化后再提交 对比差异 git diff可以用于对比当前状态和版本库中状态的变化 提交日志 git log可以查看提交日志 回归到指定版本 git reset –hard 为仓储添加远端（服务器端）地址 将本地仓储的提交记录推送到远端的master分支 拉取远端master分支的更新记录到本地 回归到指定版本 GITHUB基本使用 https://github.com/ GITHUB是一个GIT服务的提供商， 提出社交化编程 http://zoomzhao.github.io/code-guide/https://github.com/jobbole/awesome-javascript-cnhttps://github.com/jobbole/awesome-css-cn GIT分支 Angular入门简介 知识储备 什么是Angular 快速构建Web应用程序 单页面应用程序 Angular的特性 为什么要用Angular 让Web应用程序开发更简单，更快捷 带领前端进入MV*的时代 开始使用 引用Angular 下载 bower npm 基本使用]]></content>
  </entry>
  <entry>
    <title><![CDATA[构建前端自动化工作流环境]]></title>
    <url>%2Fblog%2F2016%2F10%2F24%2Fgit-guid%2F</url>
    <content type="text"><![CDATA[学习目标 了解什么是Node，什么是NPM；（Node.js） 掌握Bower的使用； 熟练使用Less/Sass； 搭建一个自己的自动化工作流环境； 自动编译 自动合并 自动刷新 自动部署 GIT 与 GITHUB master 托管源文件 gh-pages 托管部署文件 在github搭建自己的blog 为什么要有自动化的流程 在我们的开发过程中有大量的重复操作 DRY Don’t repeat yourself 开发人员的精力应放在哪？创造，新的一切 前端开发的编译操作 1.Node环境1.1.什么是Node Node.js 可能类似jquery.js 不是JS文件，也不是一个JS框架（） 而是Server side Javascript runtime, 服务端的一个JS运行时 我们可以在NODE运行JS代码 alert();ECMAScript JS- ES BOM DOM node中只能运行ECMAScript，无法使用 BOM 和 DOM 目前我们的JS是运行在浏览器内核中 PHP是什么？是一门脚本语言也是一个运行环境 为什么Node选中了JS， 说到底就是一个JS运行环境 目前有两个分支 Node.js 0.12.7 官方版本 要求尽善尽美 IO.js 是社区的产物，不是官方的东西，io.js有很多新特性，迭代非常快，社区推进非常快 15年两者合并，发布node第一个正式版 4.0， 迭代速度又慢了 node 5.x == io.js node 4.0 == node 1.2.Node环境搭建1.2.1.Mac 安装包的方式 pkg NVM（Node Version Manager） 1234$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.30.2/install.sh | bash$ echo '. ~/.nvm/nvm.sh' &gt;&gt; .bash_profile$ nvm install stable$ nvm alias default stable 1.2.2.Windows 安装包的方式 msi_x64 msi_x86 NVM（Node Version Manager） nvm(node version manager) 因为NODE版本比较多，开发人员可能依赖很多版本 通过NVM，可以轻松切换于不同的版本之间 1 NVM_HOME=C:\Develop\nvm NVM_SYMLINK=C:\Develop\nodejs NPM_HOME=C:\Develop\nvm\npm PATH=%NVM_HOME%;%NVM_SYMLINK%;%NPM_HOME% 1.2.3.环境变量 环境变量就是操作系统提供的系统级别用于存储变量的地方 系统变量和用户变量 系统变量指的是所用当前系统用户共享的变量 自己的电脑一般只有一个用户 建议将自己配置的环境变量放在用户变量中，用户变量比较干净 环境变量的变量名是不区分大小写的 变量间运行相互引用 特殊值： PATH变量（不区分大小写） PATH 相当于一个路径的引用 只要添加到PATH变量中的路径，都可以在任何目录下搜索 命令行 可以用来执行当前目录下的文件 命令 cd :change directory Node.js是一个轻内核（本身没有什么功能）的东东，所有的功能都要功能包提供 node官方提供了一些最基础的包 1.3.Node用途REPL环境（控制台环境）1.3.1.开发Web应用程序 做动态网站 开发提供数据的服务端API 1.3.2.前端开发工具基础 Node.js给前端乃至整个开发行业带来一场工业革命 刀跟火种 1.4.Node开发Web应用Demo1.4.1.复习请求与响应客户端发送到服务端的东西称之为请求报文服务端返回给客户端的东西称之为响应报文 1.5.NPM1.5.1.什么是NPMhttps://www.npmjs.com/ Node Package Manager Node应用程序依赖包的管理工具 安装卸载更新之类的操作 1.5.2.为什么使用NPM 包很多 场景：我需要用一个A，A依赖B，B依赖C 常见的包管理工具都有循环依赖的功能 你只需记住你要什么东西 1.5.3.常见的NPM操作// 安装一个包，默认安装最新稳定版本npm install package_name// –save// 初始化操作，给项目添加一个配置文件npm init// –yes参数走默认配置 如果官方数据源太慢使用 https://npm.taobao.org/ 2.Bower2.1.什么是Bower 官网 web应用程序依赖项管理工具 2.2.为什么使用Bower 方便便捷的方式管理包，zhuangbi 2.3.Bower实践 npm install -g bower // -g:global 修改npm全局路径，就是在用户目录下添加.npmrc文件 3.Sass/LESS 4.Gulp4.1.Gulp简介 链接： 官网 中文网 就是用来机械化的完成重复性质的工作 gulp的机制就是将重复工作抽象成一个个的任务， 4.2.Gulp准备工作 安装Node.js 安装 gulp 命令行工具 npm install -g gulp 初始化 gulp 项目 创建任务 - gulpfile.js 4.3.基本使用4.4.常用插件 编译 Less：gulp-less 创建本地服务器：gulp-connect 合并文件：gulp-concat 最小化 js 文件：gulp-uglify 重命名文件：gulp-rename 最小化 css 文件：gulp-minify-css 压缩html文件 gulp-minify-html 最小化图像：gulp-imagemin 5.Git5.1.什么是GIT，什么是GITHUB GIT GITHUB 5.2.环境安装5.3.GIT常用命令 6.Markdownhttps://guides.github.com/features/mastering-markdown/https://help.github.com/articles/github-flavored-markdown/https://help.github.com/articles/markdown-basics/]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fblog%2F2016%2F10%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
